# PersonalManager é¡¹ç›®çŠ¶æ€è‡ªåŠ¨åŒ–ä¸è„šæœ¬è®¾è®¡

> **ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-09-11  
> **é€‚ç”¨æ¡†æ¶**: BMAD Framework v4.43.1  
> **æ–‡æ¡£ç›®æ ‡**: è®¾è®¡ç¨³å®šå¯é çš„è‡ªåŠ¨åŒ–è„šæœ¬ä½“ç³»ï¼Œå®ç°é¡¹ç›®çŠ¶æ€çš„æ™ºèƒ½åˆ†æå’Œè‡ªåŠ¨ç”Ÿæˆ  
> **æ–‡æ¡£çŠ¶æ€**: æŠ€æœ¯è®¾è®¡å®Œæˆ  

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡PersonalManagerçš„è‡ªåŠ¨åŒ–è„šæœ¬ä½“ç³»ï¼ŒåŒ…æ‹¬PROJECT_STATUS.mdæŠ¥å‘Šè§£æã€è·¨é¡¹ç›®çŠ¶æ€èšåˆã€AIå·¥å…·é›†æˆæ¥å£ç­‰æ ¸å¿ƒç»„ä»¶ï¼Œç¡®ä¿èƒ½å¤Ÿå‡†ç¡®å¤„ç†AIç”Ÿæˆçš„é¡¹ç›®æŠ¥å‘Šå¹¶æä¾›æ™ºèƒ½çš„é¡¹ç›®ç®¡ç†å»ºè®®ã€‚

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç›®æ ‡

### è‡ªåŠ¨åŒ–åŸåˆ™
- **AIæŠ¥å‘Šé©±åŠ¨**: ä»¥AIå·¥å…·ç”Ÿæˆçš„PROJECT_STATUS.mdä¸ºæ ¸å¿ƒæ•°æ®æº
- **å¤šé¡¹ç›®ç±»å‹æ”¯æŒ**: é€‚é…ä»£ç ã€è®¾è®¡ã€è§†é¢‘ã€ç ”ç©¶ã€è‰ºæœ¯ç­‰å¤šç§é¡¹ç›®ç±»å‹
- **æ™ºèƒ½è§£æ**: å‡†ç¡®æå–æŠ¥å‘Šä¸­çš„ç»“æ„åŒ–ä¿¡æ¯å’Œè¯­ä¹‰å†…å®¹
- **å®æ—¶ç›‘æ§**: ç›‘æ§æŠ¥å‘Šæ–‡ä»¶å˜åŒ–ï¼ŒåŠæ—¶æ›´æ–°é¡¹ç›®çŠ¶æ€æ¦‚è§ˆ

### æŠ€æœ¯è¦æ±‚
- è§£æYAML frontmatterå’ŒMarkdownå†…å®¹çš„æ··åˆæ ¼å¼
- æ”¯æŒClaude Codeã€Geminiã€Cortexç­‰AIå·¥å…·ç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼
- æä¾›è·¨é¡¹ç›®çš„çŠ¶æ€èšåˆå’Œä¼˜å…ˆçº§è®¡ç®—
- é›†æˆæ–‡ä»¶ç³»ç»Ÿç›‘æ§å’ŒAIå·¥å…·æ¥å£è°ƒç”¨

## ğŸ” PROJECT_STATUS.mdæŠ¥å‘Šè§£æè„šæœ¬è®¾è®¡

### æ ¸å¿ƒè§£æå¼•æ“

#### ProjectReportParser ç±»è®¾è®¡
```python
class ProjectReportParser:
    """PROJECT_STATUS.mdæŠ¥å‘Šè§£æå™¨ - æ ¸å¿ƒçŠ¶æ€è§£æç»„ä»¶"""
    
    def __init__(self, projects_root_path: str, config: dict = None):
        """
        åˆå§‹åŒ–æŠ¥å‘Šè§£æå™¨
        
        Args:
            projects_root_path: é¡¹ç›®æ ¹ç›®å½•è·¯å¾„
            config: é…ç½®å‚æ•° {
                'supported_ai_tools': ['claude', 'gemini', 'cortex'],
                'report_filename': 'PROJECT_STATUS.md',
                'fallback_detection': True,
                'cache_duration': 300  # 5åˆ†é’Ÿç¼“å­˜
            }
        """
        self.projects_root = Path(projects_root_path)
        self.config = config or self._default_config()
        self.cache = {}
        self.logger = self._setup_logger()
    
    def scan_all_projects(self) -> Dict[str, ProjectStatus]:
        """
        æ‰«ææ‰€æœ‰é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œè§£æPROJECT_STATUS.mdæŠ¥å‘Š
        
        Returns:
            Dict[project_name, ProjectStatus]: æ‰€æœ‰é¡¹ç›®çš„è§£æç»“æœ
        """
        try:
            all_projects = {}
            
            # 1. å‘ç°é¡¹ç›®æ–‡ä»¶å¤¹
            project_folders = self._discover_project_folders()
            
            # 2. è§£ææ¯ä¸ªé¡¹ç›®çš„çŠ¶æ€æŠ¥å‘Š
            for folder_path in project_folders:
                project_name = folder_path.name
                project_status = self._parse_single_project(folder_path)
                all_projects[project_name] = project_status
            
            # 3. åº”ç”¨ç¼“å­˜ç­–ç•¥
            self._update_cache(all_projects)
            
            return all_projects
            
        except Exception as e:
            self.logger.error(f"é¡¹ç›®æ‰«æå¤±è´¥: {str(e)}")
            return self._fallback_to_cache()
    
    def _discover_project_folders(self) -> List[Path]:
        """å‘ç°åŒ…å«é¡¹ç›®çš„æ–‡ä»¶å¤¹"""
        project_folders = []
        
        for item in self.projects_root.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                # æ£€æŸ¥æ˜¯å¦åŒ…å«PROJECT_STATUS.mdæˆ–å…·æœ‰é¡¹ç›®ç‰¹å¾
                if self._is_project_folder(item):
                    project_folders.append(item)
        
        return sorted(project_folders, key=lambda x: x.stat().st_mtime, reverse=True)
    
    def _is_project_folder(self, folder_path: Path) -> bool:
        """åˆ¤æ–­æ–‡ä»¶å¤¹æ˜¯å¦ä¸ºé¡¹ç›®æ–‡ä»¶å¤¹"""
        status_file = folder_path / self.config['report_filename']
        
        # ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦å­˜åœ¨PROJECT_STATUS.md
        if status_file.exists():
            return True
        
        # å¦‚æœå¼€å¯äº†fallbackæ£€æµ‹ï¼Œé€šè¿‡æ–‡ä»¶ç‰¹å¾åˆ¤æ–­
        if self.config.get('fallback_detection', True):
            return self._detect_project_by_features(folder_path)
        
        return False
    
    def _detect_project_by_features(self, folder_path: Path) -> bool:
        """é€šè¿‡æ–‡ä»¶ç‰¹å¾æ£€æµ‹é¡¹ç›®ç±»å‹"""
        project_indicators = {
            'code': ['.py', '.js', '.java', '.cpp', '.go', '.rs'],
            'design': ['.psd', '.ai', '.sketch', '.fig', '.xd'],
            'video': ['.mp4', '.mov', '.ae', '.pr', '.fcpx'],
            'research': ['.pdf', '.docx', '.tex', '.bib'],
            'art': ['.jpg', '.png', '.svg', '.blend', '.max']
        }
        
        file_extensions = set()
        try:
            for file_path in folder_path.rglob('*'):
                if file_path.is_file():
                    file_extensions.add(file_path.suffix.lower())
        except PermissionError:
            return False
        
        # å¦‚æœåŒ…å«ä»»ä½•é¡¹ç›®ç±»å‹çš„ç‰¹å¾æ–‡ä»¶ï¼Œè®¤ä¸ºæ˜¯é¡¹ç›®
        for project_type, extensions in project_indicators.items():
            if any(ext in file_extensions for ext in extensions):
                return True
        
        return False
    
    def _parse_single_project(self, project_folder: Path) -> ProjectStatus:
        """è§£æå•ä¸ªé¡¹ç›®çš„çŠ¶æ€æŠ¥å‘Š"""
        status_file = project_folder / self.config['report_filename']
        
        if not status_file.exists():
            return self._create_placeholder_status(project_folder)
        
        try:
            # è¯»å–å’Œè§£ææ–‡ä»¶å†…å®¹
            content = status_file.read_text(encoding='utf-8')
            yaml_data, markdown_content = self._extract_structured_content(content)
            
            # æ„å»ºProjectStatuså¯¹è±¡
            return ProjectStatus(
                project_name=yaml_data.get('project_name', project_folder.name),
                project_type=yaml_data.get('project_type', self._classify_project_type(project_folder)),
                current_progress=self._normalize_progress(yaml_data.get('current_progress', 0)),
                health_status=yaml_data.get('health_status', 'unknown'),
                last_updated=self._parse_date(yaml_data.get('last_updated')),
                estimated_remaining_time=yaml_data.get('estimated_remaining_time'),
                
                # ä»Markdownå†…å®¹ä¸­æå–çš„ä¿¡æ¯
                completed_work=self._extract_completed_work(markdown_content),
                current_issues=self._extract_current_issues(markdown_content),
                next_actions=self._extract_next_actions(markdown_content),
                time_planning=self._extract_time_planning(markdown_content),
                risk_factors=self._extract_risk_factors(markdown_content),
                
                # å…ƒæ•°æ®
                folder_path=str(project_folder),
                report_source='ai_generated' if self._detect_ai_source(content) else 'manual',
                file_last_modified=datetime.fromtimestamp(status_file.stat().st_mtime)
            )
            
        except Exception as e:
            self.logger.warning(f"è§£æé¡¹ç›® {project_folder.name} å¤±è´¥: {str(e)}")
            return self._create_error_status(project_folder, str(e))
    
    def _extract_structured_content(self, content: str) -> Tuple[dict, str]:
        """æå–YAML front matterå’ŒMarkdownå†…å®¹"""
        if content.startswith('---'):
            parts = content.split('---', 2)
            if len(parts) >= 3:
                try:
                    yaml_data = yaml.safe_load(parts[1])
                    markdown_content = parts[2].strip()
                    return yaml_data or {}, markdown_content
                except yaml.YAMLError as e:
                    self.logger.warning(f"YAMLè§£æå¤±è´¥: {e}")
        
        # å¦‚æœæ²¡æœ‰YAML front matterï¼Œå°è¯•ä»å†…å®¹ä¸­æå–ç»“æ„åŒ–ä¿¡æ¯
        return {}, content
    
    def _extract_completed_work(self, content: str) -> List[str]:
        """ä»Markdownå†…å®¹ä¸­æå–å·²å®Œæˆå·¥ä½œ"""
        completed_patterns = [
            r'#{1,6}\s*.*?å·²å®Œæˆ.*?\n(.*?)(?=#{1,6}|$)',
            r'#{1,6}\s*.*?âœ….*?\n(.*?)(?=#{1,6}|$)',
            r'- \[x\] (.+)',
            r'âœ… (.+)'
        ]
        
        completed_work = []
        for pattern in completed_patterns:
            matches = re.findall(pattern, content, re.DOTALL | re.MULTILINE)
            for match in matches:
                if isinstance(match, str):
                    lines = match.strip().split('\n')
                    for line in lines:
                        clean_line = re.sub(r'^[-*â€¢]\s*', '', line.strip())
                        if clean_line and clean_line not in completed_work:
                            completed_work.append(clean_line)
        
        return completed_work[:10]  # é™åˆ¶æ•°é‡
    
    def _extract_next_actions(self, content: str) -> List[str]:
        """æå–ä¸‹ä¸€æ­¥è¡ŒåŠ¨"""
        next_action_patterns = [
            r'#{1,6}\s*.*?ä¸‹æ¬¡.*?\n(.*?)(?=#{1,6}|$)',
            r'#{1,6}\s*.*?å¾…åŠ.*?\n(.*?)(?=#{1,6}|$)',
            r'- \[ \] (.+)',
            r'ğŸ”¥ (.+)',
            r'ğŸ“‹ (.+)'
        ]
        
        next_actions = []
        for pattern in next_action_patterns:
            matches = re.findall(pattern, content, re.DOTALL | re.MULTILINE)
            for match in matches:
                if isinstance(match, str):
                    lines = match.strip().split('\n')
                    for line in lines:
                        clean_line = re.sub(r'^[-*â€¢]\s*', '', line.strip())
                        if clean_line and clean_line not in next_actions:
                            next_actions.append(clean_line)
        
        return next_actions[:5]  # é™åˆ¶æ•°é‡
    
    def _create_placeholder_status(self, project_folder: Path) -> ProjectStatus:
        """ä¸ºæ²¡æœ‰çŠ¶æ€æŠ¥å‘Šçš„é¡¹ç›®åˆ›å»ºå ä½ç¬¦çŠ¶æ€"""
        return ProjectStatus(
            project_name=project_folder.name,
            project_type=self._classify_project_type(project_folder),
            current_progress=0,
            health_status='unknown',
            last_updated=datetime.now(),
            completed_work=[],
            next_actions=['éœ€è¦åˆ›å»ºPROJECT_STATUS.mdæŠ¥å‘Š'],
            folder_path=str(project_folder),
            report_source='placeholder'
        )
```

#### AIå·¥å…·æ£€æµ‹ä¸å…¼å®¹æ€§å¤„ç†

```python
class AIToolCompatibilityManager:
    """AIå·¥å…·å…¼å®¹æ€§ç®¡ç†å™¨ - å¤„ç†ä¸åŒAIå·¥å…·ç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼"""
    
    def __init__(self):
        self.tool_signatures = {
            'claude': ['ğŸ¤– Generated with Claude', 'Co-Authored-By: Claude'],
            'gemini': ['Generated by Gemini', 'Gemini AI Assistant'],
            'cortex': ['Created with Cortex', 'Cortex AI'],
            'chatgpt': ['Generated by ChatGPT', 'OpenAI Assistant']
        }
    
    def detect_ai_source(self, content: str) -> str:
        """æ£€æµ‹æŠ¥å‘Šçš„AIå·¥å…·æ¥æº"""
        for tool, signatures in self.tool_signatures.items():
            for signature in signatures:
                if signature in content:
                    return tool
        return 'unknown'
    
    def normalize_report_format(self, content: str, detected_tool: str) -> str:
        """æ ‡å‡†åŒ–ä¸åŒAIå·¥å…·ç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼"""
        if detected_tool == 'claude':
            return self._normalize_claude_format(content)
        elif detected_tool == 'gemini':
            return self._normalize_gemini_format(content)
        elif detected_tool == 'cortex':
            return self._normalize_cortex_format(content)
        else:
            return content
    
    def _normalize_claude_format(self, content: str) -> str:
        """æ ‡å‡†åŒ–Claudeç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼"""
        # Claudeé€šå¸¸ç”Ÿæˆç»“æ„è‰¯å¥½çš„Markdownï¼Œä¸»è¦å¤„ç†ç‰¹æ®Šæ ‡è®°
        content = re.sub(r'<.*?>', '', content, flags=re.DOTALL)
        return content
    
    def _normalize_gemini_format(self, content: str) -> str:
        """æ ‡å‡†åŒ–Geminiç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼"""
        # Geminiå¯èƒ½ä½¿ç”¨ä¸åŒçš„æ ‡é¢˜æ ¼å¼ï¼Œç»Ÿä¸€è½¬æ¢
        content = re.sub(r'\*\*(.*?)\*\*', r'## \1', content)
        return content
    
    def _normalize_cortex_format(self, content: str) -> str:
        """æ ‡å‡†åŒ–Cortexç”Ÿæˆçš„æŠ¥å‘Šæ ¼å¼"""
        # Cortexå¯èƒ½ä½¿ç”¨ç‰¹æ®Šçš„æ ¼å¼æ ‡è®°ï¼Œéœ€è¦è½¬æ¢
        content = re.sub(r'===\s*(.*?)\s*===', r'## \1', content)
        return content
```

### æ–‡ä»¶ç³»ç»Ÿç›‘æ§ä¸å®æ—¶æ›´æ–°

```python
class ProjectFileMonitor:
    """é¡¹ç›®æ–‡ä»¶ç›‘æ§å™¨ - ç›‘æ§PROJECT_STATUS.mdæ–‡ä»¶å˜åŒ–"""
    
    def __init__(self, projects_root: str, callback: callable):
        self.projects_root = Path(projects_root)
        self.callback = callback
        self.observer = Observer()
        self.is_monitoring = False
    
    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§é¡¹ç›®æ–‡ä»¶å˜åŒ–"""
        if not self.is_monitoring:
            handler = ProjectFileHandler(self.callback)
            self.observer.schedule(handler, str(self.projects_root), recursive=True)
            self.observer.start()
            self.is_monitoring = True
            print(f"å¼€å§‹ç›‘æ§é¡¹ç›®ç›®å½•: {self.projects_root}")
    
    def stop_monitoring(self):
        """åœæ­¢æ–‡ä»¶ç›‘æ§"""
        if self.is_monitoring:
            self.observer.stop()
            self.observer.join()
            self.is_monitoring = False
            print("å·²åœæ­¢æ–‡ä»¶ç›‘æ§")

class ProjectFileHandler(FileSystemEventHandler):
    """æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶å¤„ç†å™¨"""
    
    def __init__(self, callback: callable):
        self.callback = callback
        self.last_modified = {}
    
    def on_modified(self, event):
        if event.is_directory:
            return
        
        # åªå¤„ç†PROJECT_STATUS.mdæ–‡ä»¶
        if event.src_path.endswith('PROJECT_STATUS.md'):
            # é˜²æ­¢é‡å¤è§¦å‘
            now = time.time()
            if (event.src_path not in self.last_modified or 
                now - self.last_modified[event.src_path] > 1):
                
                self.last_modified[event.src_path] = now
                project_folder = Path(event.src_path).parent
                self.callback(project_folder, 'modified')
    
    def on_created(self, event):
        if event.is_directory:
            return
        
        if event.src_path.endswith('PROJECT_STATUS.md'):
            project_folder = Path(event.src_path).parent
            self.callback(project_folder, 'created')
```

## ğŸ“Š è·¨é¡¹ç›®çŠ¶æ€èšåˆç®—æ³•

### å¤šé¡¹ç›®çŠ¶æ€åˆ†æå¼•æ“

#### CrossProjectStatusAggregator ç±»è®¾è®¡
```python
class CrossProjectStatusAggregator:
    """è·¨é¡¹ç›®çŠ¶æ€èšåˆå™¨ - åŸºäºPROJECT_STATUS.mdæŠ¥å‘Šçš„ç»¼åˆåˆ†æç»„ä»¶"""
    
    def __init__(self, project_path: str, project_config: dict = None):
        """
        åˆå§‹åŒ–è¿›åº¦è®¡ç®—å™¨
        
        Args:
            project_path: é¡¹ç›®è·¯å¾„
            project_config: é¡¹ç›®é…ç½® {
                'project_type': 'coding|learning|writing|design',
                'progress_weights': {...},
                'milestones': [...],
                'custom_indicators': [...]
            }
        """
        self.project_path = project_path
        self.project_config = project_config or self._detect_project_type()
        self.git_analyzer = GitActivityAnalyzer(project_path)
        self.logger = self._setup_logger()
    
    def calculate_overall_progress(self) -> dict:
        """
        è®¡ç®—é¡¹ç›®æ•´ä½“è¿›åº¦
        
        Returns:
            {
                'overall_percentage': float,
                'dimension_scores': {...},
                'progress_trend': 'increasing|stable|decreasing',
                'completion_prediction': {...},
                'confidence_level': float
            }
        """
        try:
            # 1. è®¡ç®—å„ç»´åº¦è¿›åº¦
            dimensions = self._calculate_progress_dimensions()
            
            # 2. åŠ æƒè®¡ç®—æ€»ä½“è¿›åº¦
            overall_progress = self._calculate_weighted_progress(dimensions)
            
            # 3. åˆ†æè¿›åº¦è¶‹åŠ¿
            trend = self._analyze_progress_trend()
            
            # 4. é¢„æµ‹å®Œæˆæ—¶é—´
            prediction = self._predict_completion()
            
            # 5. è®¡ç®—ç½®ä¿¡åº¦
            confidence = self._calculate_confidence(dimensions)
            
            return {
                'overall_percentage': round(overall_progress, 1),
                'dimension_scores': dimensions,
                'progress_trend': trend,
                'completion_prediction': prediction,
                'confidence_level': confidence,
                'calculation_time': datetime.now().isoformat(),
                'calculation_method': self.project_config.get('project_type', 'generic')
            }
            
        except Exception as e:
            self.logger.error(f"è¿›åº¦è®¡ç®—å¤±è´¥: {str(e)}")
            return self._generate_fallback_progress()
    
    def _calculate_progress_dimensions(self) -> dict:
        """è®¡ç®—å„ç»´åº¦è¿›åº¦åˆ†æ•°"""
        dimensions = {}
        project_type = self.project_config.get('project_type', 'generic')
        
        if project_type == 'coding':
            dimensions = self._calculate_coding_progress()
        elif project_type == 'learning':
            dimensions = self._calculate_learning_progress()
        elif project_type == 'writing':
            dimensions = self._calculate_writing_progress()
        elif project_type == 'design':
            dimensions = self._calculate_design_progress()
        else:
            dimensions = self._calculate_generic_progress()
        
        return dimensions
    
    def _calculate_coding_progress(self) -> dict:
        """è®¡ç®—ç¼–ç¨‹é¡¹ç›®è¿›åº¦"""
        progress = {}
        
        # 1. ä»£ç æ–‡ä»¶å®Œæˆåº¦ (40%æƒé‡)
        code_completion = self._analyze_code_files()
        progress['code_completion'] = {
            'score': code_completion,
            'weight': 0.4,
            'description': 'ä»£ç æ–‡ä»¶å®ç°å®Œæˆåº¦'
        }
        
        # 2. TODO/FIXMEå®Œæˆæƒ…å†µ (20%æƒé‡)
        todo_completion = self._analyze_todo_items()
        progress['todo_completion'] = {
            'score': todo_completion,
            'weight': 0.2,
            'description': 'TODOå’ŒFIXMEé¡¹ç›®å®Œæˆæƒ…å†µ'
        }
        
        # 3. æµ‹è¯•è¦†ç›–åº¦ (15%æƒé‡)
        test_coverage = self._analyze_test_coverage()
        progress['test_coverage'] = {
            'score': test_coverage,
            'weight': 0.15,
            'description': 'æµ‹è¯•ç”¨ä¾‹è¦†ç›–ç¨‹åº¦'
        }
        
        # 4. æ–‡æ¡£å®Œæˆåº¦ (10%æƒé‡)
        doc_completion = self._analyze_documentation()
        progress['documentation'] = {
            'score': doc_completion,
            'weight': 0.1,
            'description': 'é¡¹ç›®æ–‡æ¡£å®Œæˆç¨‹åº¦'
        }
        
        # 5. Gitæäº¤æ´»è·ƒåº¦ (15%æƒé‡)
        git_activity = self._analyze_git_activity_score()
        progress['git_activity'] = {
            'score': git_activity,
            'weight': 0.15,
            'description': 'ä»£ç æäº¤æ´»è·ƒç¨‹åº¦'
        }
        
        return progress
    
    def _calculate_learning_progress(self) -> dict:
        """è®¡ç®—å­¦ä¹ é¡¹ç›®è¿›åº¦"""
        progress = {}
        
        # 1. å­¦ä¹ ææ–™å®Œæˆåº¦ (50%æƒé‡)
        material_completion = self._analyze_learning_materials()
        progress['material_completion'] = {
            'score': material_completion,
            'weight': 0.5,
            'description': 'å­¦ä¹ ææ–™å®Œæˆç¨‹åº¦'
        }
        
        # 2. ç»ƒä¹ å’Œä½œä¸šå®Œæˆåº¦ (30%æƒé‡)
        exercise_completion = self._analyze_exercises()
        progress['exercise_completion'] = {
            'score': exercise_completion,
            'weight': 0.3,
            'description': 'ç»ƒä¹ å’Œä½œä¸šå®Œæˆæƒ…å†µ'
        }
        
        # 3. ç¬”è®°å’Œæ€»ç»“è´¨é‡ (20%æƒé‡)
        note_quality = self._analyze_notes_quality()
        progress['note_quality'] = {
            'score': note_quality,
            'weight': 0.2,
            'description': 'å­¦ä¹ ç¬”è®°å’Œæ€»ç»“è´¨é‡'
        }
        
        return progress
    
    def _calculate_writing_progress(self) -> dict:
        """è®¡ç®—å†™ä½œé¡¹ç›®è¿›åº¦"""
        progress = {}
        
        # 1. å­—æ•°å®Œæˆåº¦ (40%æƒé‡)
        word_count_progress = self._analyze_word_count()
        progress['word_count'] = {
            'score': word_count_progress,
            'weight': 0.4,
            'description': 'ç›®æ ‡å­—æ•°å®Œæˆç¨‹åº¦'
        }
        
        # 2. ç« èŠ‚å®Œæˆåº¦ (35%æƒé‡)
        chapter_completion = self._analyze_chapters()
        progress['chapter_completion'] = {
            'score': chapter_completion,
            'weight': 0.35,
            'description': 'ç« èŠ‚ç»“æ„å®Œæˆç¨‹åº¦'
        }
        
        # 3. ç¼–è¾‘å’Œä¿®è®¢è¿›åº¦ (25%æƒé‡)
        revision_progress = self._analyze_revisions()
        progress['revision_progress'] = {
            'score': revision_progress,
            'weight': 0.25,
            'description': 'ç¼–è¾‘å’Œä¿®è®¢å®Œæˆç¨‹åº¦'
        }
        
        return progress
    
    def _calculate_generic_progress(self) -> dict:
        """è®¡ç®—é€šç”¨é¡¹ç›®è¿›åº¦"""
        progress = {}
        
        # 1. æ–‡ä»¶å®Œæˆåº¦ (30%æƒé‡)
        file_completion = self._analyze_file_completion()
        progress['file_completion'] = {
            'score': file_completion,
            'weight': 0.3,
            'description': 'é¡¹ç›®æ–‡ä»¶å®Œæˆç¨‹åº¦'
        }
        
        # 2. Gitæ´»åŠ¨åº¦ (25%æƒé‡)
        git_activity = self._analyze_git_activity_score()
        progress['git_activity'] = {
            'score': git_activity,
            'weight': 0.25,
            'description': 'Gitæ´»åŠ¨æ´»è·ƒç¨‹åº¦'
        }
        
        # 3. ä»»åŠ¡å®Œæˆåº¦ (25%æƒé‡)
        task_completion = self._analyze_task_completion()
        progress['task_completion'] = {
            'score': task_completion,
            'weight': 0.25,
            'description': 'æ˜ç¡®ä»»åŠ¡å®Œæˆæƒ…å†µ'
        }
        
        # 4. æ—¶é—´è¿›å±•åº¦ (20%æƒé‡)
        time_progress = self._analyze_time_progress()
        progress['time_progress'] = {
            'score': time_progress,
            'weight': 0.2,
            'description': 'ç›¸å¯¹æ—¶é—´è¿›å±•ç¨‹åº¦'
        }
        
        return progress
    
    def _analyze_code_files(self) -> float:
        """åˆ†æä»£ç æ–‡ä»¶å®Œæˆåº¦"""
        try:
            code_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs']
            total_files = 0
            completed_files = 0
            
            for root, dirs, files in os.walk(self.project_path):
                # è·³è¿‡ç‰ˆæœ¬æ§åˆ¶å’Œä¾èµ–ç›®å½•
                dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__', 'venv']]
                
                for file in files:
                    if any(file.endswith(ext) for ext in code_extensions):
                        total_files += 1
                        file_path = os.path.join(root, file)
                        
                        # ç®€å•çš„å®Œæˆåº¦åˆ¤æ–­ï¼šæ–‡ä»¶å¤§å°å’ŒTODOæ•°é‡
                        if self._is_file_substantially_complete(file_path):
                            completed_files += 1
            
            return (completed_files / total_files * 100) if total_files > 0 else 0
            
        except Exception as e:
            self.logger.warning(f"ä»£ç æ–‡ä»¶åˆ†æå¤±è´¥: {str(e)}")
            return 50  # é»˜è®¤å€¼
    
    def _is_file_substantially_complete(self, file_path: str) -> bool:
        """åˆ¤æ–­æ–‡ä»¶æ˜¯å¦åŸºæœ¬å®Œæˆ"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # åŸºäºå¯å‘å¼è§„åˆ™åˆ¤æ–­
            lines = content.split('\n')
            non_empty_lines = [line for line in lines if line.strip()]
            
            # è§„åˆ™1: æ–‡ä»¶ä¸èƒ½å¤ªçŸ­ï¼ˆå°‘äº10è¡Œæœ‰æ•ˆä»£ç ï¼‰
            if len(non_empty_lines) < 10:
                return False
            
            # è§„åˆ™2: TODO/FIXMEä¸èƒ½å¤ªå¤šï¼ˆè¶…è¿‡æœ‰æ•ˆè¡Œæ•°çš„20%ï¼‰
            todo_count = len([line for line in lines if 'TODO' in line or 'FIXME' in line])
            if todo_count > len(non_empty_lines) * 0.2:
                return False
            
            # è§„åˆ™3: ä¸èƒ½æœ‰æ˜æ˜¾çš„å ä½ç¬¦
            placeholder_patterns = ['pass', 'NotImplemented', '// TODO', '# TODO']
            placeholder_count = sum(content.count(pattern) for pattern in placeholder_patterns)
            if placeholder_count > 3:
                return False
            
            return True
            
        except Exception:
            return False
    
    def _analyze_todo_items(self) -> float:
        """åˆ†æTODO/FIXMEå®Œæˆæƒ…å†µ"""
        try:
            total_todos = 0
            completed_todos = 0
            
            for root, dirs, files in os.walk(self.project_path):
                dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__']]
                
                for file in files:
                    if file.endswith(('.py', '.js', '.ts', '.java', '.cpp', '.c', '.md')):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                            
                            # æŸ¥æ‰¾TODOé¡¹ç›®
                            todo_pattern = r'(?:TODO|FIXME|HACK|XXX)[\s:]*(.+)'
                            todos = re.findall(todo_pattern, content, re.IGNORECASE)
                            total_todos += len(todos)
                            
                            # æŸ¥æ‰¾å·²å®Œæˆçš„TODO (é€šè¿‡æ³¨é‡Šæ‰æˆ–DONEæ ‡è®°)
                            done_pattern = r'(?:DONE|COMPLETED|FIXED)[\s:]*(.+)'
                            completed = re.findall(done_pattern, content, re.IGNORECASE)
                            completed_todos += len(completed)
                            
                        except Exception:
                            continue
            
            if total_todos == 0:
                return 100  # æ²¡æœ‰TODOé¡¹ç›®ï¼Œè®¤ä¸ºæ˜¯å®ŒæˆçŠ¶æ€
            
            completion_rate = (completed_todos / (total_todos + completed_todos)) * 100
            return min(completion_rate, 100)
            
        except Exception as e:
            self.logger.warning(f"TODOåˆ†æå¤±è´¥: {str(e)}")
            return 70  # é»˜è®¤å€¼
    
    def _analyze_time_progress(self) -> float:
        """åˆ†ææ—¶é—´è¿›å±•"""
        try:
            # ä»é¡¹ç›®é…ç½®æˆ–çŠ¶æ€æ–‡ä»¶è·å–æ—¶é—´ä¿¡æ¯
            start_date = self._get_project_start_date()
            target_date = self._get_project_target_date()
            
            if not start_date or not target_date:
                return self._estimate_time_progress_from_git()
            
            now = datetime.now().date()
            total_days = (target_date - start_date).days
            elapsed_days = (now - start_date).days
            
            time_progress = (elapsed_days / total_days) * 100 if total_days > 0 else 0
            return max(0, min(time_progress, 100))
            
        except Exception as e:
            self.logger.warning(f"æ—¶é—´è¿›å±•åˆ†æå¤±è´¥: {str(e)}")
            return 50  # é»˜è®¤å€¼
    
    def _calculate_weighted_progress(self, dimensions: dict) -> float:
        """åŠ æƒè®¡ç®—æ€»ä½“è¿›åº¦"""
        total_weighted_score = 0
        total_weight = 0
        
        for dimension_name, dimension_data in dimensions.items():
            score = dimension_data['score']
            weight = dimension_data['weight']
            
            total_weighted_score += score * weight
            total_weight += weight
        
        return (total_weighted_score / total_weight) if total_weight > 0 else 0
    
    def _analyze_progress_trend(self, days_back: int = 7) -> str:
        """åˆ†æè¿›åº¦è¶‹åŠ¿"""
        try:
            # è·å–è¿‡å»å‡ å¤©çš„è¿›åº¦æ•°æ®
            progress_history = self._get_progress_history(days_back)
            
            if len(progress_history) < 2:
                return 'stable'  # æ•°æ®ä¸è¶³
            
            # è®¡ç®—è¶‹åŠ¿æ–œç‡
            recent_progress = progress_history[-3:]  # æœ€è¿‘3ä¸ªæ•°æ®ç‚¹
            if len(recent_progress) < 2:
                return 'stable'
            
            trend_slope = (recent_progress[-1] - recent_progress[0]) / len(recent_progress)
            
            if trend_slope > 2:
                return 'increasing'
            elif trend_slope < -2:
                return 'decreasing'
            else:
                return 'stable'
                
        except Exception as e:
            self.logger.warning(f"è¶‹åŠ¿åˆ†æå¤±è´¥: {str(e)}")
            return 'stable'
    
    def _predict_completion(self) -> dict:
        """é¢„æµ‹é¡¹ç›®å®Œæˆæ—¶é—´"""
        try:
            current_progress = self.calculate_overall_progress()['overall_percentage']
            
            if current_progress >= 95:
                return {
                    'estimated_days': 0,
                    'confidence': 'high',
                    'completion_date': datetime.now().date().isoformat()
                }
            
            # åŸºäºå†å²è¿›åº¦è¶‹åŠ¿é¢„æµ‹
            progress_history = self._get_progress_history(14)  # è¿‡å»ä¸¤å‘¨
            if len(progress_history) >= 5:
                # è®¡ç®—å¹³å‡æ¯æ—¥è¿›åº¦
                daily_progress = self._calculate_daily_progress_rate(progress_history)
                remaining_progress = 100 - current_progress
                
                if daily_progress > 0:
                    estimated_days = remaining_progress / daily_progress
                    completion_date = (datetime.now().date() + timedelta(days=int(estimated_days)))
                    
                    # è®¡ç®—ç½®ä¿¡åº¦
                    confidence = 'high' if len(progress_history) >= 10 else 'medium'
                    
                    return {
                        'estimated_days': round(estimated_days, 1),
                        'confidence': confidence,
                        'completion_date': completion_date.isoformat(),
                        'daily_progress_rate': round(daily_progress, 2)
                    }
            
            # å¦‚æœå†å²æ•°æ®ä¸è¶³ï¼Œä½¿ç”¨ç®€å•ä¼°ç®—
            return self._simple_completion_estimate(current_progress)
            
        except Exception as e:
            self.logger.warning(f"å®Œæˆæ—¶é—´é¢„æµ‹å¤±è´¥: {str(e)}")
            return {
                'estimated_days': None,
                'confidence': 'low',
                'completion_date': None,
                'error': str(e)
            }
    
    def _calculate_confidence(self, dimensions: dict) -> float:
        """è®¡ç®—è¿›åº¦è®¡ç®—çš„ç½®ä¿¡åº¦"""
        confidence_factors = []
        
        # å› ç´ 1: æ•°æ®æ¥æºçš„å¤šæ ·æ€§
        data_sources = len(dimensions)
        source_confidence = min(data_sources / 4, 1) * 0.3  # æœ€å¤š4ä¸ªç»´åº¦ï¼Œå 30%æƒé‡
        confidence_factors.append(source_confidence)
        
        # å› ç´ 2: Gitæ´»åŠ¨çš„ä¸€è‡´æ€§
        git_activity = self.git_analyzer.analyze_recent_activity('week')
        activity_consistency = min(git_activity['metrics'].get('commits_count', 0) / 7, 1) * 0.2
        confidence_factors.append(activity_consistency)
        
        # å› ç´ 3: é¡¹ç›®ç±»å‹æ£€æµ‹çš„å‡†ç¡®æ€§
        project_type_confidence = 0.3 if self.project_config.get('project_type') != 'generic' else 0.1
        confidence_factors.append(project_type_confidence)
        
        # å› ç´ 4: æ—¶é—´æ•°æ®çš„å¯ç”¨æ€§
        time_data_confidence = 0.2 if self._has_reliable_time_data() else 0.05
        confidence_factors.append(time_data_confidence)
        
        total_confidence = sum(confidence_factors)
        return round(min(total_confidence, 1.0), 2)
```

## ğŸ”„ è‡ªåŠ¨åŒ–è§¦å‘æœºåˆ¶è®¾è®¡

### è§¦å‘å™¨ç³»ç»Ÿæ¶æ„

#### AutomationTriggerManager ç±»è®¾è®¡
```python
class AutomationTriggerManager:
    """è‡ªåŠ¨åŒ–è§¦å‘ç®¡ç†å™¨ - åè°ƒå„ç§è§¦å‘æœºåˆ¶"""
    
    def __init__(self, config_path: str = None):
        """
        åˆå§‹åŒ–è§¦å‘ç®¡ç†å™¨
        
        Args:
            config_path: é…ç½®æ–‡ä»¶è·¯å¾„ {
                'git_hooks': {...},
                'scheduled_tasks': {...},
                'file_watchers': {...},
                'manual_triggers': {...}
            }
        """
        self.config = self._load_config(config_path)
        self.git_hook_manager = GitHookManager(self.config.get('git_hooks', {}))
        self.scheduler = TaskScheduler(self.config.get('scheduled_tasks', {}))
        self.file_watcher = FileWatcherManager(self.config.get('file_watchers', {}))
        self.logger = self._setup_logger()
        self.is_running = False
    
    def initialize_automation(self, project_paths: List[str]) -> dict:
        """
        åˆå§‹åŒ–è‡ªåŠ¨åŒ–ç³»ç»Ÿ
        
        Args:
            project_paths: éœ€è¦ç›‘æ§çš„é¡¹ç›®è·¯å¾„åˆ—è¡¨
            
        Returns:
            åˆå§‹åŒ–ç»“æœå’ŒçŠ¶æ€ä¿¡æ¯
        """
        results = {
            'git_hooks': {},
            'scheduled_tasks': {},
            'file_watchers': {},
            'errors': []
        }
        
        try:
            # 1. å®‰è£…Git hooks
            for project_path in project_paths:
                hook_result = self.git_hook_manager.install_hooks(project_path)
                results['git_hooks'][project_path] = hook_result
            
            # 2. å¯åŠ¨å®šæ—¶ä»»åŠ¡
            scheduler_result = self.scheduler.start_scheduled_tasks(project_paths)
            results['scheduled_tasks'] = scheduler_result
            
            # 3. å¯åŠ¨æ–‡ä»¶ç›‘æ§
            watcher_result = self.file_watcher.start_watching(project_paths)
            results['file_watchers'] = watcher_result
            
            self.is_running = True
            self.logger.info("è‡ªåŠ¨åŒ–ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
            
            return results
            
        except Exception as e:
            self.logger.error(f"è‡ªåŠ¨åŒ–ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {str(e)}")
            results['errors'].append(str(e))
            return results
    
    def trigger_status_update(self, project_path: str, trigger_type: str, context: dict = None) -> dict:
        """
        æ‰§è¡Œé¡¹ç›®çŠ¶æ€æ›´æ–°
        
        Args:
            project_path: é¡¹ç›®è·¯å¾„
            trigger_type: è§¦å‘ç±»å‹ ('git_commit', 'scheduled', 'file_change', 'manual')
            context: è§¦å‘ä¸Šä¸‹æ–‡ä¿¡æ¯
            
        Returns:
            æ›´æ–°ç»“æœ
        """
        try:
            self.logger.info(f"è§¦å‘é¡¹ç›®çŠ¶æ€æ›´æ–°: {project_path} ({trigger_type})")
            
            # 1. æ£€æŸ¥é¡¹ç›®çŠ¶æ€
            if not self._validate_project(project_path):
                return {'success': False, 'error': 'é¡¹ç›®è·¯å¾„æ— æ•ˆæˆ–ä¸å¯è®¿é—®'}
            
            # 2. é˜²æ­¢é‡å¤è§¦å‘
            if self._is_recent_update(project_path, trigger_type):
                self.logger.debug(f"è·³è¿‡é‡å¤æ›´æ–°: {project_path}")
                return {'success': True, 'skipped': True, 'reason': 'æœ€è¿‘å·²æ›´æ–°'}
            
            # 3. æ‰§è¡ŒçŠ¶æ€ç”Ÿæˆ
            status_generator = ProjectStatusGenerator(project_path)
            update_result = status_generator.update_status_file()
            
            # 4. è®°å½•æ›´æ–°å†å²
            self._record_update_history(project_path, trigger_type, context)
            
            # 5. é€šçŸ¥PersonalManager Agent
            if self.config.get('notify_agent', True):
                self._notify_agent(project_path, update_result)
            
            return {
                'success': True,
                'project_path': project_path,
                'trigger_type': trigger_type,
                'status_file': update_result,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"çŠ¶æ€æ›´æ–°å¤±è´¥: {project_path} - {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'project_path': project_path,
                'trigger_type': trigger_type
            }


class GitHookManager:
    """Git Hookç®¡ç†å™¨ - å¤„ç†Gitç›¸å…³çš„è‡ªåŠ¨åŒ–è§¦å‘"""
    
    def __init__(self, config: dict):
        self.config = config
        self.logger = self._setup_logger()
    
    def install_hooks(self, project_path: str) -> dict:
        """
        ä¸ºé¡¹ç›®å®‰è£…Git hooks
        
        Args:
            project_path: é¡¹ç›®è·¯å¾„
            
        Returns:
            å®‰è£…ç»“æœ
        """
        hooks_dir = os.path.join(project_path, '.git', 'hooks')
        if not os.path.exists(hooks_dir):
            return {'success': False, 'error': 'ä¸æ˜¯Gitä»“åº“'}
        
        results = {}
        
        # 1. post-commit hook - æäº¤åè§¦å‘
        if self.config.get('post_commit_enabled', True):
            post_commit_result = self._install_post_commit_hook(hooks_dir, project_path)
            results['post_commit'] = post_commit_result
        
        # 2. pre-push hook - æ¨é€å‰è§¦å‘ï¼ˆå¯é€‰ï¼‰
        if self.config.get('pre_push_enabled', False):
            pre_push_result = self._install_pre_push_hook(hooks_dir, project_path)
            results['pre_push'] = pre_push_result
        
        return results
    
    def _install_post_commit_hook(self, hooks_dir: str, project_path: str) -> dict:
        """å®‰è£…post-commit hook"""
        hook_file = os.path.join(hooks_dir, 'post-commit')
        
        hook_script = f"""#!/bin/bash
# PersonalManager è‡ªåŠ¨çŠ¶æ€æ›´æ–° Hook
# åœ¨æ¯æ¬¡Gitæäº¤åè‡ªåŠ¨æ›´æ–°é¡¹ç›®çŠ¶æ€

set -e

PROJECT_PATH="{project_path}"
SCRIPT_PATH="{self._get_trigger_script_path()}"

# æ£€æŸ¥è§¦å‘è„šæœ¬æ˜¯å¦å­˜åœ¨
if [ ! -f "$SCRIPT_PATH" ]; then
    echo "Warning: PersonalManager trigger script not found at $SCRIPT_PATH"
    exit 0
fi

# å¼‚æ­¥è§¦å‘çŠ¶æ€æ›´æ–°ï¼Œé¿å…å½±å“Gitæ“ä½œæ€§èƒ½
nohup python3 "$SCRIPT_PATH" update-status \\
    --project-path "$PROJECT_PATH" \\
    --trigger-type "git_commit" \\
    --async \\
    > /dev/null 2>&1 &

echo "PersonalManager: é¡¹ç›®çŠ¶æ€æ›´æ–°å·²è§¦å‘"
exit 0
"""
        
        try:
            # å¤‡ä»½ç°æœ‰hook
            if os.path.exists(hook_file):
                backup_file = f"{hook_file}.backup.{int(time.time())}"
                shutil.copy2(hook_file, backup_file)
                self.logger.info(f"ç°æœ‰hookå·²å¤‡ä»½åˆ°: {backup_file}")
            
            # å†™å…¥æ–°çš„hook
            with open(hook_file, 'w') as f:
                f.write(hook_script)
            
            # è®¾ç½®æ‰§è¡Œæƒé™
            os.chmod(hook_file, 0o755)
            
            # æµ‹è¯•hook
            test_result = self._test_git_hook(hook_file)
            
            return {
                'success': True,
                'hook_file': hook_file,
                'test_result': test_result
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f"å®‰è£…post-commit hookå¤±è´¥: {str(e)}"
            }
    
    def _test_git_hook(self, hook_file: str) -> dict:
        """æµ‹è¯•Git hookæ˜¯å¦æ­£å¸¸å·¥ä½œ"""
        try:
            # ç®€å•çš„è¯­æ³•æ£€æŸ¥
            result = subprocess.run(['bash', '-n', hook_file], 
                                 capture_output=True, text=True)
            
            if result.returncode == 0:
                return {'success': True, 'message': 'Hookè„šæœ¬è¯­æ³•æ£€æŸ¥é€šè¿‡'}
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': f"Hookæµ‹è¯•å¤±è´¥: {str(e)}"}


class TaskScheduler:
    """ä»»åŠ¡è°ƒåº¦å™¨ - å¤„ç†å®šæ—¶è§¦å‘çš„è‡ªåŠ¨åŒ–ä»»åŠ¡"""
    
    def __init__(self, config: dict):
        self.config = config
        self.scheduler = schedule
        self.logger = self._setup_logger()
        self.running_jobs = []
    
    def start_scheduled_tasks(self, project_paths: List[str]) -> dict:
        """
        å¯åŠ¨å®šæ—¶ä»»åŠ¡
        
        Args:
            project_paths: é¡¹ç›®è·¯å¾„åˆ—è¡¨
            
        Returns:
            å¯åŠ¨ç»“æœ
        """
        results = {'jobs': [], 'errors': []}
        
        # 1. æ¯æ—¥æ€»ç»“ä»»åŠ¡ (æ™šä¸Š6ç‚¹)
        if self.config.get('daily_summary_enabled', True):
            daily_time = self.config.get('daily_summary_time', '18:00')
            job = self.scheduler.every().day.at(daily_time).do(
                self._daily_summary_task, project_paths
            )
            results['jobs'].append({
                'type': 'daily_summary',
                'schedule': f'æ¯æ—¥ {daily_time}',
                'job_id': id(job)
            })
        
        # 2. å‘¨åº¦åˆ†æä»»åŠ¡ (å‘¨æ—¥æ™šä¸Š8ç‚¹)
        if self.config.get('weekly_analysis_enabled', True):
            weekly_time = self.config.get('weekly_analysis_time', '20:00')
            job = self.scheduler.every().sunday.at(weekly_time).do(
                self._weekly_analysis_task, project_paths
            )
            results['jobs'].append({
                'type': 'weekly_analysis',
                'schedule': f'æ¯å‘¨æ—¥ {weekly_time}',
                'job_id': id(job)
            })
        
        # 3. é¡¹ç›®å¥åº·æ£€æŸ¥ (æ¯å¤©ä¸Šåˆ9ç‚¹)
        if self.config.get('health_check_enabled', True):
            health_time = self.config.get('health_check_time', '09:00')
            job = self.scheduler.every().day.at(health_time).do(
                self._health_check_task, project_paths
            )
            results['jobs'].append({
                'type': 'health_check',
                'schedule': f'æ¯æ—¥ {health_time}',
                'job_id': id(job)
            })
        
        # 4. å¯åŠ¨è°ƒåº¦å™¨çº¿ç¨‹
        if results['jobs']:
            self._start_scheduler_thread()
            self.logger.info(f"å·²å¯åŠ¨ {len(results['jobs'])} ä¸ªå®šæ—¶ä»»åŠ¡")
        
        return results
    
    def _daily_summary_task(self, project_paths: List[str]):
        """æ¯æ—¥æ€»ç»“ä»»åŠ¡"""
        self.logger.info("æ‰§è¡Œæ¯æ—¥æ€»ç»“ä»»åŠ¡")
        
        for project_path in project_paths:
            try:
                # ç”Ÿæˆæ¯æ—¥å·¥ä½œæ€»ç»“
                trigger_manager = AutomationTriggerManager()
                trigger_manager.trigger_status_update(
                    project_path, 
                    'scheduled_daily',
                    {'task_type': 'daily_summary'}
                )
            except Exception as e:
                self.logger.error(f"æ¯æ—¥æ€»ç»“ä»»åŠ¡å¤±è´¥: {project_path} - {str(e)}")
    
    def _weekly_analysis_task(self, project_paths: List[str]):
        """å‘¨åº¦åˆ†æä»»åŠ¡"""
        self.logger.info("æ‰§è¡Œå‘¨åº¦åˆ†æä»»åŠ¡")
        
        try:
            # ç”Ÿæˆå‘¨åº¦é¡¹ç›®åˆ†ææŠ¥å‘Š
            weekly_analyzer = WeeklyProjectAnalyzer(project_paths)
            analysis_result = weekly_analyzer.generate_weekly_report()
            
            # ä¿å­˜åˆ†ææŠ¥å‘Š
            report_path = self._save_weekly_report(analysis_result)
            self.logger.info(f"å‘¨åº¦åˆ†ææŠ¥å‘Šå·²ä¿å­˜: {report_path}")
            
        except Exception as e:
            self.logger.error(f"å‘¨åº¦åˆ†æä»»åŠ¡å¤±è´¥: {str(e)}")
    
    def _health_check_task(self, project_paths: List[str]):
        """é¡¹ç›®å¥åº·æ£€æŸ¥ä»»åŠ¡"""
        self.logger.info("æ‰§è¡Œé¡¹ç›®å¥åº·æ£€æŸ¥")
        
        unhealthy_projects = []
        
        for project_path in project_paths:
            try:
                health_checker = ProjectHealthChecker(project_path)
                health_status = health_checker.check_project_health()
                
                if health_status['status'] in ['warning', 'critical']:
                    unhealthy_projects.append({
                        'path': project_path,
                        'status': health_status['status'],
                        'issues': health_status['issues']
                    })
                    
            except Exception as e:
                self.logger.error(f"å¥åº·æ£€æŸ¥å¤±è´¥: {project_path} - {str(e)}")
        
        # å¦‚æœå‘ç°é—®é¢˜é¡¹ç›®ï¼Œå‘é€é€šçŸ¥
        if unhealthy_projects:
            self._send_health_alert(unhealthy_projects)
    
    def _start_scheduler_thread(self):
        """å¯åŠ¨è°ƒåº¦å™¨çº¿ç¨‹"""
        def run_scheduler():
            while True:
                self.scheduler.run_pending()
                time.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
        
        scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
        scheduler_thread.start()
        self.logger.info("è°ƒåº¦å™¨çº¿ç¨‹å·²å¯åŠ¨")


class FileWatcherManager:
    """æ–‡ä»¶ç›‘æ§ç®¡ç†å™¨ - å¤„ç†æ–‡ä»¶å˜åŒ–è§¦å‘çš„è‡ªåŠ¨åŒ–"""
    
    def __init__(self, config: dict):
        self.config = config
        self.observers = []
        self.logger = self._setup_logger()
    
    def start_watching(self, project_paths: List[str]) -> dict:
        """
        å¯åŠ¨æ–‡ä»¶ç›‘æ§
        
        Args:
            project_paths: éœ€è¦ç›‘æ§çš„é¡¹ç›®è·¯å¾„
            
        Returns:
            ç›‘æ§å¯åŠ¨ç»“æœ
        """
        if not self.config.get('enabled', False):
            return {'success': True, 'message': 'æ–‡ä»¶ç›‘æ§å·²ç¦ç”¨'}
        
        results = {'watchers': [], 'errors': []}
        
        for project_path in project_paths:
            try:
                observer = Observer()
                event_handler = ProjectFileEventHandler(
                    project_path, 
                    self.config.get('file_patterns', ['*.py', '*.js', '*.md']),
                    self.config.get('debounce_seconds', 30)
                )
                
                observer.schedule(event_handler, project_path, recursive=True)
                observer.start()
                
                self.observers.append(observer)
                results['watchers'].append({
                    'project_path': project_path,
                    'status': 'watching'
                })
                
            except Exception as e:
                results['errors'].append({
                    'project_path': project_path,
                    'error': str(e)
                })
        
        self.logger.info(f"å·²å¯åŠ¨ {len(results['watchers'])} ä¸ªæ–‡ä»¶ç›‘æ§å™¨")
        return results


class ProjectFileEventHandler(FileSystemEventHandler):
    """é¡¹ç›®æ–‡ä»¶äº‹ä»¶å¤„ç†å™¨"""
    
    def __init__(self, project_path: str, file_patterns: List[str], debounce_seconds: int):
        self.project_path = project_path
        self.file_patterns = file_patterns
        self.debounce_seconds = debounce_seconds
        self.last_trigger_time = 0
        self.logger = self._setup_logger()
    
    def on_modified(self, event):
        """æ–‡ä»¶ä¿®æ”¹äº‹ä»¶"""
        if event.is_directory:
            return
        
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åŒ¹é…ç›‘æ§æ¨¡å¼
        if not self._should_monitor_file(event.src_path):
            return
        
        # é˜²æŠ–åŠ¨å¤„ç†
        current_time = time.time()
        if current_time - self.last_trigger_time < self.debounce_seconds:
            return
        
        self.last_trigger_time = current_time
        
        # å¼‚æ­¥è§¦å‘çŠ¶æ€æ›´æ–°
        self._async_trigger_update(event.src_path)
    
    def _should_monitor_file(self, file_path: str) -> bool:
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦éœ€è¦ç›‘æ§"""
        file_name = os.path.basename(file_path)
        
        # å¿½ç•¥æŸäº›æ–‡ä»¶å’Œç›®å½•
        ignore_patterns = ['.git/', '__pycache__/', 'node_modules/', '.DS_Store']
        for pattern in ignore_patterns:
            if pattern in file_path:
                return False
        
        # æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        for pattern in self.file_patterns:
            if fnmatch.fnmatch(file_name, pattern):
                return True
        
        return False
    
    def _async_trigger_update(self, changed_file: str):
        """å¼‚æ­¥è§¦å‘çŠ¶æ€æ›´æ–°"""
        def trigger_update():
            try:
                trigger_manager = AutomationTriggerManager()
                trigger_manager.trigger_status_update(
                    self.project_path,
                    'file_change',
                    {'changed_file': changed_file}
                )
            except Exception as e:
                self.logger.error(f"æ–‡ä»¶å˜åŒ–è§¦å‘æ›´æ–°å¤±è´¥: {str(e)}")
        
        # åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œé¿å…é˜»å¡æ–‡ä»¶ç›‘æ§
        threading.Thread(target=trigger_update, daemon=True).start()
```

### Git Hook å®‰è£…å’Œé…ç½®

#### å®‰è£…è„šæœ¬è®¾è®¡
```bash
#!/bin/bash
# install-automation.sh - PersonalManagerè‡ªåŠ¨åŒ–ç³»ç»Ÿå®‰è£…è„šæœ¬

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PM_HOME="$HOME/.personal-manager"
VENV_PATH="$PM_HOME/venv"

echo "ğŸš€ PersonalManager è‡ªåŠ¨åŒ–ç³»ç»Ÿå®‰è£…ç¨‹åº"
echo "============================================"

# 1. åˆ›å»ºç³»ç»Ÿç›®å½•
echo "ğŸ“ åˆ›å»ºç³»ç»Ÿç›®å½•..."
mkdir -p "$PM_HOME"/{scripts,logs,config,data}

# 2. è®¾ç½®Pythonè™šæ‹Ÿç¯å¢ƒ
if [ ! -d "$VENV_PATH" ]; then
    echo "ğŸ åˆ›å»ºPythonè™šæ‹Ÿç¯å¢ƒ..."
    python3 -m venv "$VENV_PATH"
fi

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
source "$VENV_PATH/bin/activate"

# 3. å®‰è£…ä¾èµ–
echo "ğŸ“¦ å®‰è£…Pythonä¾èµ–..."
pip install gitpython schedule watchdog pyyaml

# 4. å¤åˆ¶è„šæœ¬æ–‡ä»¶
echo "ğŸ“‹ å®‰è£…è„šæœ¬æ–‡ä»¶..."
cp -r "$SCRIPT_DIR/scripts/"* "$PM_HOME/scripts/"
chmod +x "$PM_HOME/scripts/"*.py

# 5. åˆ›å»ºé…ç½®æ–‡ä»¶
if [ ! -f "$PM_HOME/config/automation.yaml" ]; then
    echo "âš™ï¸ åˆ›å»ºé»˜è®¤é…ç½®..."
    cat > "$PM_HOME/config/automation.yaml" << EOF
# PersonalManager è‡ªåŠ¨åŒ–é…ç½®

git_hooks:
  post_commit_enabled: true
  pre_push_enabled: false
  hook_timeout: 30

scheduled_tasks:
  daily_summary_enabled: true
  daily_summary_time: "18:00"
  weekly_analysis_enabled: true
  weekly_analysis_time: "20:00"
  health_check_enabled: true
  health_check_time: "09:00"

file_watchers:
  enabled: false  # é»˜è®¤ç¦ç”¨ï¼Œæ€§èƒ½å½±å“è¾ƒå¤§
  file_patterns: ["*.py", "*.js", "*.md", "*.txt"]
  debounce_seconds: 30

notification:
  notify_agent: true
  log_level: "INFO"
EOF
fi

# 6. åˆ›å»ºå‘½ä»¤è¡Œå·¥å…·
echo "ğŸ”§ åˆ›å»ºå‘½ä»¤è¡Œå·¥å…·..."
cat > "$PM_HOME/scripts/pm-automation" << 'EOF'
#!/bin/bash
# PersonalManager è‡ªåŠ¨åŒ–å‘½ä»¤è¡Œå·¥å…·

VENV_PATH="$HOME/.personal-manager/venv"
SCRIPT_PATH="$HOME/.personal-manager/scripts"

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
source "$VENV_PATH/bin/activate"

# æ‰§è¡ŒPythonè„šæœ¬
python3 "$SCRIPT_PATH/automation_cli.py" "$@"
EOF

chmod +x "$PM_HOME/scripts/pm-automation"

# 7. åˆ›å»ºç¬¦å·é“¾æ¥åˆ°ç³»ç»ŸPATH
if [ ! -L "/usr/local/bin/pm-automation" ]; then
    echo "ğŸ”— åˆ›å»ºç³»ç»Ÿé“¾æ¥..."
    sudo ln -sf "$PM_HOME/scripts/pm-automation" /usr/local/bin/pm-automation
fi

# 8. åˆå§‹åŒ–ç³»ç»Ÿ
echo "ğŸ¯ åˆå§‹åŒ–è‡ªåŠ¨åŒ–ç³»ç»Ÿ..."
"$PM_HOME/scripts/pm-automation" init --config "$PM_HOME/config/automation.yaml"

echo "âœ… PersonalManagerè‡ªåŠ¨åŒ–ç³»ç»Ÿå®‰è£…å®Œæˆï¼"
echo ""
echo "ä½¿ç”¨æ–¹æ³•ï¼š"
echo "  pm-automation init          # åˆå§‹åŒ–é¡¹ç›®è‡ªåŠ¨åŒ–"
echo "  pm-automation status        # æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€"
echo "  pm-automation update PATH   # æ‰‹åŠ¨æ›´æ–°é¡¹ç›®çŠ¶æ€"
echo "  pm-automation config        # ç¼–è¾‘é…ç½®æ–‡ä»¶"
echo ""
echo "æ—¥å¿—æ–‡ä»¶: $PM_HOME/logs/"
echo "é…ç½®æ–‡ä»¶: $PM_HOME/config/automation.yaml"
```

#### ä½¿ç”¨ç¤ºä¾‹
```bash
# 1. å®‰è£…è‡ªåŠ¨åŒ–ç³»ç»Ÿ
curl -sSL https://github.com/your-repo/install.sh | bash

# 2. åˆå§‹åŒ–é¡¹ç›®è‡ªåŠ¨åŒ–
cd /path/to/your/project
pm-automation init

# 3. æŸ¥çœ‹è‡ªåŠ¨åŒ–çŠ¶æ€
pm-automation status

# 4. æ‰‹åŠ¨è§¦å‘çŠ¶æ€æ›´æ–°
pm-automation update /path/to/project

# 5. ç¼–è¾‘é…ç½®
pm-automation config
```

## ğŸ“„ çŠ¶æ€æ–‡æ¡£ç”Ÿæˆé€»è¾‘è®¾è®¡

### ProjectStatusGenerator å¢å¼ºç‰ˆ

#### æ ¸å¿ƒç”Ÿæˆå¼•æ“
```python
class ProjectStatusGenerator:
    """é¡¹ç›®çŠ¶æ€ç”Ÿæˆå™¨ - æ™ºèƒ½ç”ŸæˆPROJECT_STATUS.md"""
    
    def __init__(self, project_path: str, template_config: dict = None):
        """
        åˆå§‹åŒ–çŠ¶æ€ç”Ÿæˆå™¨
        
        Args:
            project_path: é¡¹ç›®è·¯å¾„
            template_config: æ¨¡æ¿é…ç½® {
                'template_name': 'coding|learning|writing|generic',
                'custom_sections': [...],
                'merge_strategy': 'preserve_manual|override|smart_merge'
            }
        """
        self.project_path = project_path
        self.template_config = template_config or self._detect_template_config()
        self.git_analyzer = GitActivityAnalyzer(project_path)
        self.progress_calculator = ProjectProgressCalculator(project_path)
        self.logger = self._setup_logger()
        
        # æ¨¡æ¿å’Œè¾“å‡ºé…ç½®
        self.status_file_path = os.path.join(project_path, "PROJECT_STATUS.md")
        self.template_loader = StatusTemplateLoader()
        self.content_merger = ContentMerger()
    
    def generate_complete_status(self) -> dict:
        """
        ç”Ÿæˆå®Œæ•´çš„é¡¹ç›®çŠ¶æ€æŠ¥å‘Š
        
        Returns:
            {
                'status_content': str,
                'metadata': {...},
                'generation_info': {...}
            }
        """
        try:
            self.logger.info(f"å¼€å§‹ç”Ÿæˆé¡¹ç›®çŠ¶æ€: {self.project_path}")
            
            # 1. æ”¶é›†æ‰€æœ‰æ•°æ®
            data = self._collect_all_data()
            
            # 2. åŠ è½½é€‚å½“çš„æ¨¡æ¿
            template = self._load_template()
            
            # 3. ç”ŸæˆçŠ¶æ€å†…å®¹
            status_content = self._render_status_content(template, data)
            
            # 4. å¤„ç†ç°æœ‰å†…å®¹åˆå¹¶
            if os.path.exists(self.status_file_path):
                status_content = self._merge_with_existing_content(status_content)
            
            # 5. ç”Ÿæˆå…ƒæ•°æ®
            metadata = self._generate_metadata(data)
            
            return {
                'status_content': status_content,
                'metadata': metadata,
                'generation_info': {
                    'timestamp': datetime.now().isoformat(),
                    'generator_version': '1.0.0',
                    'template_used': self.template_config.get('template_name'),
                    'data_sources': list(data.keys())
                }
            }
            
        except Exception as e:
            self.logger.error(f"çŠ¶æ€ç”Ÿæˆå¤±è´¥: {str(e)}")
            return self._generate_error_status(e)
    
    def _collect_all_data(self) -> dict:
        """æ”¶é›†ç”ŸæˆçŠ¶æ€æ–‡æ¡£éœ€è¦çš„æ‰€æœ‰æ•°æ®"""
        data = {}
        
        try:
            # 1. é¡¹ç›®åŸºæœ¬ä¿¡æ¯
            data['project_info'] = self._collect_project_info()
            
            # 2. Gitæ´»åŠ¨æ•°æ®
            data['git_activity'] = self.git_analyzer.analyze_recent_activity('today')
            data['git_weekly'] = self.git_analyzer.analyze_recent_activity('week')
            
            # 3. è¿›åº¦è®¡ç®—æ•°æ®
            data['progress'] = self.progress_calculator.calculate_overall_progress()
            
            # 4. ä»»åŠ¡å’ŒTODOåˆ†æ
            data['tasks'] = self._analyze_tasks_and_todos()
            
            # 5. æ–‡ä»¶åˆ†æ
            data['files'] = self._analyze_project_files()
            
            # 6. é‡Œç¨‹ç¢‘å’Œç›®æ ‡
            data['milestones'] = self._analyze_milestones()
            
            # 7. å·¥ä½œé‡ç‚¹é¢„æµ‹
            data['next_priorities'] = self._predict_next_priorities(data)
            
            # 8. å¥åº·çŠ¶æ€
            data['health'] = self._assess_project_health(data)
            
            return data
            
        except Exception as e:
            self.logger.error(f"æ•°æ®æ”¶é›†å¤±è´¥: {str(e)}")
            return {'error': str(e)}
    
    def _collect_project_info(self) -> dict:
        """æ”¶é›†é¡¹ç›®åŸºæœ¬ä¿¡æ¯"""
        info = {
            'name': os.path.basename(self.project_path),
            'path': self.project_path,
            'type': self._detect_project_type(),
            'created_date': self._get_project_creation_date(),
            'last_activity': self._get_last_activity_date(),
            'size_info': self._get_project_size_info()
        }
        
        # å°è¯•ä»ç°æœ‰çŠ¶æ€æ–‡ä»¶è¯»å–é…ç½®ä¿¡æ¯
        existing_config = self._extract_existing_config()
        if existing_config:
            info.update(existing_config)
        
        return info
    
    def _detect_project_type(self) -> str:
        """æ£€æµ‹é¡¹ç›®ç±»å‹"""
        # æ£€æµ‹æ–‡ä»¶æ‰©å±•ååˆ†å¸ƒ
        extensions = {}
        for root, dirs, files in os.walk(self.project_path):
            # è·³è¿‡éšè—ç›®å½•å’Œç‰ˆæœ¬æ§åˆ¶ç›®å½•
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__']]
            
            for file in files:
                ext = os.path.splitext(file)[1].lower()
                if ext:
                    extensions[ext] = extensions.get(ext, 0) + 1
        
        # åŸºäºæ–‡ä»¶æ‰©å±•ååˆ¤æ–­ç±»å‹
        if any(ext in extensions for ext in ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs']):
            return 'coding'
        elif any(ext in extensions for ext in ['.md', '.txt', '.docx', '.pdf']):
            if extensions.get('.md', 0) > 5:  # å¤šä¸ªmarkdownæ–‡ä»¶ï¼Œå¯èƒ½æ˜¯å­¦ä¹ ç¬”è®°
                return 'learning'
            else:
                return 'writing'
        elif any(ext in extensions for ext in ['.psd', '.ai', '.sketch', '.fig']):
            return 'design'
        else:
            return 'generic'
    
    def _analyze_tasks_and_todos(self) -> dict:
        """åˆ†æä»»åŠ¡å’ŒTODOé¡¹ç›®"""
        tasks = {
            'todo_items': [],
            'completed_items': [],
            'in_progress_items': [],
            'blocked_items': [],
            'todo_stats': {}
        }
        
        try:
            # æ‰«ææ–‡ä»¶ä¸­çš„TODOé¡¹ç›®
            for root, dirs, files in os.walk(self.project_path):
                dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__']]
                
                for file in files:
                    if any(file.endswith(ext) for ext in ['.py', '.js', '.ts', '.md', '.txt', '.java', '.cpp']):
                        file_path = os.path.join(root, file)
                        file_todos = self._extract_todos_from_file(file_path)
                        
                        for todo in file_todos:
                            todo['file'] = os.path.relpath(file_path, self.project_path)
                            
                            if todo['status'] == 'todo':
                                tasks['todo_items'].append(todo)
                            elif todo['status'] == 'done':
                                tasks['completed_items'].append(todo)
                            elif todo['status'] == 'progress':
                                tasks['in_progress_items'].append(todo)
                            elif todo['status'] == 'blocked':
                                tasks['blocked_items'].append(todo)
            
            # ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
            tasks['todo_stats'] = {
                'total_todos': len(tasks['todo_items']),
                'completed': len(tasks['completed_items']),
                'in_progress': len(tasks['in_progress_items']),
                'blocked': len(tasks['blocked_items']),
                'completion_rate': len(tasks['completed_items']) / max(len(tasks['todo_items']) + len(tasks['completed_items']), 1) * 100
            }
            
            return tasks
            
        except Exception as e:
            self.logger.error(f"ä»»åŠ¡åˆ†æå¤±è´¥: {str(e)}")
            return {'error': str(e)}
    
    def _extract_todos_from_file(self, file_path: str) -> List[dict]:
        """ä»æ–‡ä»¶ä¸­æå–TODOé¡¹ç›®"""
        todos = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            lines = content.split('\n')
            for line_num, line in enumerate(lines, 1):
                # TODOæ¨¡å¼åŒ¹é…
                todo_patterns = {
                    'todo': [r'TODO[\s:]*(.+)', r'FIXME[\s:]*(.+)', r'HACK[\s:]*(.+)'],
                    'done': [r'DONE[\s:]*(.+)', r'COMPLETED[\s:]*(.+)', r'FIXED[\s:]*(.+)'],
                    'progress': [r'WIP[\s:]*(.+)', r'IN-PROGRESS[\s:]*(.+)'],
                    'blocked': [r'BLOCKED[\s:]*(.+)', r'STUCK[\s:]*(.+)']
                }
                
                for status, patterns in todo_patterns.items():
                    for pattern in patterns:
                        match = re.search(pattern, line, re.IGNORECASE)
                        if match:
                            todos.append({
                                'content': match.group(1).strip(),
                                'status': status,
                                'line_number': line_num,
                                'priority': self._extract_priority(line),
                                'assignee': self._extract_assignee(line)
                            })
                            break
            
            return todos
            
        except Exception as e:
            self.logger.error(f"æ–‡ä»¶TODOæå–å¤±è´¥: {file_path} - {str(e)}")
            return []
    
    def _extract_priority(self, line: str) -> str:
        """ä»è¡Œä¸­æå–ä¼˜å…ˆçº§"""
        if re.search(r'\b(urgent|critical|é«˜|ç´§æ€¥)\b', line, re.IGNORECASE):
            return 'high'
        elif re.search(r'\b(important|é‡è¦)\b', line, re.IGNORECASE):
            return 'medium'
        else:
            return 'low'
    
    def _analyze_milestones(self) -> dict:
        """åˆ†æé¡¹ç›®é‡Œç¨‹ç¢‘"""
        milestones = {
            'defined_milestones': [],
            'achieved_milestones': [],
            'upcoming_milestones': [],
            'milestone_progress': 0
        }
        
        try:
            # å°è¯•ä»ç°æœ‰çŠ¶æ€æ–‡ä»¶è¯»å–é‡Œç¨‹ç¢‘ä¿¡æ¯
            if os.path.exists(self.status_file_path):
                existing_milestones = self._extract_milestones_from_status()
                milestones.update(existing_milestones)
            
            # åŸºäºGitæ ‡ç­¾è‡ªåŠ¨å‘ç°é‡Œç¨‹ç¢‘
            git_milestones = self._extract_milestones_from_git()
            milestones['git_milestones'] = git_milestones
            
            # è®¡ç®—é‡Œç¨‹ç¢‘å®Œæˆåº¦
            total_milestones = len(milestones['defined_milestones'])
            achieved = len(milestones['achieved_milestones'])
            
            if total_milestones > 0:
                milestones['milestone_progress'] = (achieved / total_milestones) * 100
            
            return milestones
            
        except Exception as e:
            self.logger.error(f"é‡Œç¨‹ç¢‘åˆ†æå¤±è´¥: {str(e)}")
            return {'error': str(e)}
    
    def _predict_next_priorities(self, collected_data: dict) -> dict:
        """åŸºäºæ”¶é›†çš„æ•°æ®é¢„æµ‹ä¸‹æ¬¡å·¥ä½œé‡ç‚¹"""
        priorities = {
            'high_priority': [],
            'medium_priority': [],
            'low_priority': [],
            'suggested_focus': '',
            'reasoning': []
        }
        
        try:
            # åŸºäºTODOä¼˜å…ˆçº§
            if 'tasks' in collected_data:
                high_priority_todos = [
                    todo for todo in collected_data['tasks'].get('todo_items', [])
                    if todo.get('priority') == 'high'
                ]
                priorities['high_priority'].extend([todo['content'] for todo in high_priority_todos])
            
            # åŸºäºé¡¹ç›®è¿›åº¦
            if 'progress' in collected_data:
                progress_pct = collected_data['progress'].get('overall_percentage', 0)
                if progress_pct > 80:
                    priorities['high_priority'].append("å‡†å¤‡é¡¹ç›®å‘å¸ƒå’Œæœ€ç»ˆæµ‹è¯•")
                    priorities['suggested_focus'] = "é¡¹ç›®æ”¶å°¾é˜¶æ®µï¼Œä¸“æ³¨äºè´¨é‡ä¿è¯å’Œå‘å¸ƒå‡†å¤‡"
                elif progress_pct > 50:
                    priorities['high_priority'].append("ç»§ç»­æ ¸å¿ƒåŠŸèƒ½å¼€å‘")
                    priorities['suggested_focus'] = "å¼€å‘å…³é”®é˜¶æ®µï¼Œä¿æŒå¼€å‘èŠ‚å¥"
                else:
                    priorities['high_priority'].append("å®Œå–„åŸºç¡€æ¶æ„å’Œæ ¸å¿ƒåŠŸèƒ½")
                    priorities['suggested_focus'] = "é¡¹ç›®åˆæœŸï¼Œå»ºç«‹åšå®åŸºç¡€"
            
            # åŸºäºGitæ´»åŠ¨
            if 'git_activity' in collected_data:
                recent_activity = collected_data['git_activity']
                if recent_activity.get('commits', {}).get('total_count', 0) == 0:
                    priorities['high_priority'].append("æ¢å¤é¡¹ç›®æ´»è·ƒåº¦ï¼Œç»§ç»­å¼€å‘å·¥ä½œ")
                    priorities['reasoning'].append("é¡¹ç›®ç¼ºä¹æœ€è¿‘æ´»åŠ¨ï¼Œéœ€è¦é‡æ–°æŠ•å…¥")
            
            # åŸºäºå¥åº·çŠ¶æ€
            if 'health' in collected_data:
                health_status = collected_data['health'].get('status', 'unknown')
                if health_status in ['warning', 'critical']:
                    issues = collected_data['health'].get('issues', [])
                    for issue in issues:
                        priorities['high_priority'].append(f"ä¿®å¤å¥åº·é—®é¢˜: {issue}")
            
            return priorities
            
        except Exception as e:
            self.logger.error(f"ä¼˜å…ˆçº§é¢„æµ‹å¤±è´¥: {str(e)}")
            return {'error': str(e)}
    
    def _render_status_content(self, template: str, data: dict) -> str:
        """æ¸²æŸ“çŠ¶æ€å†…å®¹"""
        try:
            # ä½¿ç”¨Jinja2æ¨¡æ¿å¼•æ“è¿›è¡Œæ¸²æŸ“
            from jinja2 import Template, Environment, BaseLoader
            
            env = Environment(loader=BaseLoader())
            template_obj = env.from_string(template)
            
            # æ·»åŠ ä¸€äº›æœ‰ç”¨çš„è¿‡æ»¤å™¨å’Œå‡½æ•°
            env.filters['datetime_format'] = lambda dt, fmt='%Y-%m-%d %H:%M': dt.strftime(fmt) if dt else 'N/A'
            env.filters['percentage'] = lambda val: f"{val:.1f}%" if isinstance(val, (int, float)) else "N/A"
            
            rendered_content = template_obj.render(
                data=data,
                project=data.get('project_info', {}),
                git=data.get('git_activity', {}),
                progress=data.get('progress', {}),
                tasks=data.get('tasks', {}),
                milestones=data.get('milestones', {}),
                next_priorities=data.get('next_priorities', {}),
                health=data.get('health', {}),
                now=datetime.now()
            )
            
            return rendered_content
            
        except Exception as e:
            self.logger.error(f"æ¨¡æ¿æ¸²æŸ“å¤±è´¥: {str(e)}")
            return self._generate_fallback_content(data)
    
    def _merge_with_existing_content(self, new_content: str) -> str:
        """ä¸ç°æœ‰å†…å®¹åˆå¹¶"""
        try:
            merge_strategy = self.template_config.get('merge_strategy', 'smart_merge')
            
            with open(self.status_file_path, 'r', encoding='utf-8') as f:
                existing_content = f.read()
            
            if merge_strategy == 'override':
                return new_content
            elif merge_strategy == 'preserve_manual':
                return self.content_merger.preserve_manual_sections(existing_content, new_content)
            else:  # smart_merge
                return self.content_merger.smart_merge(existing_content, new_content)
                
        except Exception as e:
            self.logger.error(f"å†…å®¹åˆå¹¶å¤±è´¥: {str(e)}")
            return new_content
    
    def save_status_file(self, content: str, metadata: dict = None) -> str:
        """ä¿å­˜çŠ¶æ€æ–‡ä»¶"""
        try:
            # åˆ›å»ºå¤‡ä»½
            if os.path.exists(self.status_file_path):
                backup_path = f"{self.status_file_path}.backup.{int(time.time())}"
                shutil.copy2(self.status_file_path, backup_path)
                self.logger.info(f"ç°æœ‰æ–‡ä»¶å·²å¤‡ä»½åˆ°: {backup_path}")
            
            # å†™å…¥æ–°å†…å®¹
            with open(self.status_file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            self.logger.info(f"é¡¹ç›®çŠ¶æ€æ–‡ä»¶å·²æ›´æ–°: {self.status_file_path}")
            return self.status_file_path
            
        except Exception as e:
            self.logger.error(f"çŠ¶æ€æ–‡ä»¶ä¿å­˜å¤±è´¥: {str(e)}")
            raise


class StatusTemplateLoader:
    """çŠ¶æ€æ–‡æ¡£æ¨¡æ¿åŠ è½½å™¨"""
    
    def __init__(self):
        self.template_dir = self._get_template_directory()
    
    def load_template(self, template_name: str) -> str:
        """åŠ è½½æŒ‡å®šæ¨¡æ¿"""
        template_file = os.path.join(self.template_dir, f"{template_name}.md.j2")
        
        if os.path.exists(template_file):
            with open(template_file, 'r', encoding='utf-8') as f:
                return f.read()
        else:
            # è¿”å›å†…ç½®é»˜è®¤æ¨¡æ¿
            return self._get_default_template(template_name)
    
    def _get_default_template(self, template_name: str) -> str:
        """è·å–å†…ç½®é»˜è®¤æ¨¡æ¿"""
        if template_name == 'coding':
            return self._get_coding_template()
        elif template_name == 'learning':
            return self._get_learning_template()
        elif template_name == 'writing':
            return self._get_writing_template()
        else:
            return self._get_generic_template()
    
    def _get_generic_template(self) -> str:
        """é€šç”¨é¡¹ç›®æ¨¡æ¿"""
        return """# ğŸ“Š é¡¹ç›®çŠ¶æ€æŠ¥å‘Š - {{ project.name }}

> **æœ€åæ›´æ–°**: {{ now | datetime_format }}  
> **æ›´æ–°æ–¹å¼**: è‡ªåŠ¨ç”Ÿæˆ  
> **é¡¹ç›®ç±»å‹**: {{ project.type }}  

## ğŸ¯ é¡¹ç›®æ¦‚è§ˆ
- **é¡¹ç›®åç§°**: {{ project.name }}
- **é¡¹ç›®è·¯å¾„**: {{ project.path }}
- **å¼€å§‹æ—¥æœŸ**: {{ project.created_date | datetime_format('%Y-%m-%d') }}
- **æœ€åæ´»åŠ¨**: {{ project.last_activity | datetime_format }}
- **å½“å‰è¿›åº¦**: {{ progress.overall_percentage | percentage }}
- **å¥åº·çŠ¶æ€**: {{ "âœ… è‰¯å¥½" if health.status == "healthy" else ("âš ï¸ éœ€å…³æ³¨" if health.status == "warning" else "âŒ æœ‰é—®é¢˜") }}

## ğŸ“ˆ ä»Šæ—¥å·¥ä½œæ€»ç»“
### âœ… å·²å®Œæˆå·¥ä½œ
{% for task in git.work_summary.completed_tasks %}
- [x] {{ task.content }}
{% else %}
- ä»Šæ—¥æš‚æ— Gitæäº¤è®°å½•
{% endfor %}

### â³ è¿›è¡Œä¸­å·¥ä½œ
{% for task in tasks.in_progress_items %}
- [ ] {{ task.content }} ({{ task.file }}:{{ task.line_number }})
{% else %}
- å½“å‰æ— è¿›è¡Œä¸­ä»»åŠ¡
{% endfor %}

## ğŸ“‹ å¾…åŠäº‹é¡¹
### ğŸ”¥ é«˜ä¼˜å…ˆçº§
{% for item in next_priorities.high_priority %}
- [ ] {{ item }}
{% else %}
- æš‚æ— é«˜ä¼˜å…ˆçº§ä»»åŠ¡
{% endfor %}

### ğŸ“ˆ ä¸­ä¼˜å…ˆçº§
{% for item in next_priorities.medium_priority %}
- [ ] {{ item }}
{% else %}
- æš‚æ— ä¸­ä¼˜å…ˆçº§ä»»åŠ¡
{% endfor %}

## ğŸ“Š é¡¹ç›®æ•°æ®åˆ†æ (è‡ªåŠ¨ç”Ÿæˆ)
### Gitæ´»åŠ¨ç»Ÿè®¡
- **ä»Šæ—¥æäº¤æ¬¡æ•°**: {{ git.metrics.commits_count }}æ¬¡
- **æ´»è·ƒæ–‡ä»¶æ•°**: {{ git.file_changes.total_files_changed }}ä¸ª
- **æœ€åæäº¤**: {{ git.metrics.last_commit_time | datetime_format if git.metrics.last_commit_time else "æ— " }}

### ä»»åŠ¡å®Œæˆåº¦åˆ†æ
- **æ€»TODOæ•°é‡**: {{ tasks.todo_stats.total_todos }}ä¸ª
- **å·²å®Œæˆ**: {{ tasks.todo_stats.completed }}ä¸ª
- **è¿›è¡Œä¸­**: {{ tasks.todo_stats.in_progress }}ä¸ª
- **å®Œæˆç‡**: {{ tasks.todo_stats.completion_rate | percentage }}

## ğŸ¯ è¿›åº¦è·Ÿè¸ª
{% for milestone in milestones.defined_milestones %}
- {{ "âœ…" if milestone in milestones.achieved_milestones else "â³" }} {{ milestone }}
{% else %}
- æš‚æ— å®šä¹‰çš„é‡Œç¨‹ç¢‘
{% endfor %}

## ğŸ’¡ å»ºè®®å’Œé‡ç‚¹
{{ next_priorities.suggested_focus }}

{% if next_priorities.reasoning %}
**å†³ç­–ä¾æ®**:
{% for reason in next_priorities.reasoning %}
- {{ reason }}
{% endfor %}
{% endif %}

---
**ğŸ“ å¤‡æ³¨**: æ­¤æ–‡æ¡£ç”±PersonalManagerè‡ªåŠ¨ç”Ÿæˆï¼ŒåŸºäºGitåˆ†æå’Œé¡¹ç›®çŠ¶æ€æ£€æµ‹  
**ğŸ”„ åŒæ­¥çŠ¶æ€**: å·²åŒæ­¥åˆ°ä¸ªäººç®¡ç†ç³»ç»Ÿ ({{ now | datetime_format }})
"""


class ContentMerger:
    """å†…å®¹åˆå¹¶å™¨ - æ™ºèƒ½åˆå¹¶è‡ªåŠ¨ç”Ÿæˆå’Œæ‰‹åŠ¨ç¼–è¾‘çš„å†…å®¹"""
    
    def smart_merge(self, existing_content: str, new_content: str) -> str:
        """æ™ºèƒ½åˆå¹¶ç­–ç•¥"""
        try:
            # 1. è§£æç°æœ‰å†…å®¹ï¼Œè¯†åˆ«æ‰‹åŠ¨ç¼–è¾‘éƒ¨åˆ†
            manual_sections = self._extract_manual_sections(existing_content)
            
            # 2. è§£ææ–°å†…å®¹ç»“æ„
            new_sections = self._parse_content_sections(new_content)
            
            # 3. åˆå¹¶å†…å®¹
            merged_sections = {}
            
            for section_name, section_content in new_sections.items():
                if section_name in manual_sections:
                    # ä¿ç•™æ‰‹åŠ¨ç¼–è¾‘çš„éƒ¨åˆ†
                    merged_sections[section_name] = self._merge_section_content(
                        manual_sections[section_name], 
                        section_content
                    )
                else:
                    # ä½¿ç”¨æ–°ç”Ÿæˆçš„å†…å®¹
                    merged_sections[section_name] = section_content
            
            # 4. é‡æ„å®Œæ•´å†…å®¹
            return self._rebuild_content(merged_sections)
            
        except Exception as e:
            self.logger.error(f"æ™ºèƒ½åˆå¹¶å¤±è´¥: {str(e)}")
            return new_content
    
    def _extract_manual_sections(self, content: str) -> dict:
        """æå–æ‰‹åŠ¨ç¼–è¾‘çš„éƒ¨åˆ†"""
        manual_sections = {}
        
        # æŸ¥æ‰¾æ‰‹åŠ¨æ ‡è®°çš„éƒ¨åˆ†
        manual_markers = [
            r'<!-- MANUAL START -->(.*?)<!-- MANUAL END -->',
            r'## ğŸ’­ ä¸ªäººåæ€(.*?)(?=##|\Z)',
            r'## ğŸ“ æ‰‹åŠ¨è®°å½•(.*?)(?=##|\Z)'
        ]
        
        for marker in manual_markers:
            matches = re.findall(marker, content, re.DOTALL | re.IGNORECASE)
            for i, match in enumerate(matches):
                manual_sections[f'manual_{i}'] = match.strip()
        
        return manual_sections
```

## ğŸš¨ é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

### ç»¼åˆé”™è¯¯å¤„ç†ç³»ç»Ÿ

#### ErrorHandlerManager ç±»è®¾è®¡
```python
class ErrorHandlerManager:
    """é”™è¯¯å¤„ç†ç®¡ç†å™¨ - ç»Ÿä¸€å¤„ç†å„ç§å¼‚å¸¸æƒ…å†µ"""
    
    def __init__(self, config: dict = None):
        """
        åˆå§‹åŒ–é”™è¯¯å¤„ç†ç®¡ç†å™¨
        
        Args:
            config: é”™è¯¯å¤„ç†é…ç½® {
                'retry_attempts': int,
                'retry_delay': int,
                'fallback_enabled': bool,
                'notification_enabled': bool,
                'log_level': str
            }
        """
        self.config = config or self._default_config()
        self.logger = self._setup_logger()
        self.retry_manager = RetryManager(self.config)
        self.fallback_handler = FallbackHandler(self.config)
        self.notification_manager = NotificationManager(self.config)
        
        # é”™è¯¯ç»Ÿè®¡å’Œç›‘æ§
        self.error_stats = {
            'total_errors': 0,
            'error_types': {},
            'recovery_successes': 0,
            'recovery_failures': 0
        }
    
    def handle_error(self, error: Exception, context: dict, operation: str) -> dict:
        """
        ç»Ÿä¸€é”™è¯¯å¤„ç†å…¥å£
        
        Args:
            error: å¼‚å¸¸å¯¹è±¡
            context: é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯
            operation: æ“ä½œåç§°
            
        Returns:
            å¤„ç†ç»“æœå’Œæ¢å¤ä¿¡æ¯
        """
        try:
            # 1. è®°å½•é”™è¯¯
            error_id = self._log_error(error, context, operation)
            
            # 2. åˆ†æé”™è¯¯ç±»å‹
            error_type = self._classify_error(error)
            
            # 3. æ›´æ–°ç»Ÿè®¡
            self._update_error_stats(error_type)
            
            # 4. ç¡®å®šå¤„ç†ç­–ç•¥
            strategy = self._determine_handling_strategy(error_type, context)
            
            # 5. æ‰§è¡Œé”™è¯¯å¤„ç†
            result = self._execute_error_handling(error, context, strategy)
            
            # 6. å‘é€é€šçŸ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if self._should_notify(error_type, strategy):
                self.notification_manager.send_error_notification(error, context, result)
            
            return {
                'error_id': error_id,
                'error_type': error_type,
                'strategy': strategy,
                'result': result,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as handling_error:
            # é”™è¯¯å¤„ç†æœ¬èº«å‡ºç°é—®é¢˜ï¼Œä½¿ç”¨æœ€åŸºç¡€çš„å¤„ç†æ–¹å¼
            self.logger.critical(f"é”™è¯¯å¤„ç†å™¨æœ¬èº«å¤±è´¥: {str(handling_error)}")
            return self._emergency_fallback(error, handling_error)
    
    def _classify_error(self, error: Exception) -> str:
        """é”™è¯¯åˆ†ç±»"""
        error_classifications = {
            'git_error': [git.GitCommandError, git.InvalidGitRepositoryError],
            'file_error': [FileNotFoundError, PermissionError, IOError],
            'network_error': [ConnectionError, TimeoutError],
            'parse_error': [json.JSONDecodeError, yaml.YAMLError, UnicodeDecodeError],
            'system_error': [OSError, MemoryError, SystemError],
            'config_error': [KeyError, ValueError, AttributeError]
        }
        
        error_type = type(error)
        for category, error_types in error_classifications.items():
            if any(issubclass(error_type, err_type) for err_type in error_types):
                return category
        
        return 'unknown_error'
    
    def _determine_handling_strategy(self, error_type: str, context: dict) -> str:
        """ç¡®å®šå¤„ç†ç­–ç•¥"""
        strategies = {
            'git_error': self._get_git_error_strategy,
            'file_error': self._get_file_error_strategy,
            'network_error': self._get_network_error_strategy,
            'parse_error': self._get_parse_error_strategy,
            'system_error': self._get_system_error_strategy,
            'config_error': self._get_config_error_strategy
        }
        
        strategy_func = strategies.get(error_type, self._get_default_strategy)
        return strategy_func(context)
    
    def _get_git_error_strategy(self, context: dict) -> str:
        """Gité”™è¯¯å¤„ç†ç­–ç•¥"""
        if 'not a git repository' in str(context.get('error', '')).lower():
            return 'skip_git_analysis'
        elif 'permission denied' in str(context.get('error', '')).lower():
            return 'retry_with_elevated_permissions'
        else:
            return 'retry_git_operation'
    
    def _get_file_error_strategy(self, context: dict) -> str:
        """æ–‡ä»¶é”™è¯¯å¤„ç†ç­–ç•¥"""
        if isinstance(context.get('error'), FileNotFoundError):
            return 'create_missing_file'
        elif isinstance(context.get('error'), PermissionError):
            return 'request_permission_fix'
        else:
            return 'use_fallback_file'
    
    def _execute_error_handling(self, error: Exception, context: dict, strategy: str) -> dict:
        """æ‰§è¡Œé”™è¯¯å¤„ç†ç­–ç•¥"""
        handlers = {
            'retry_operation': self._handle_retry,
            'skip_operation': self._handle_skip,
            'use_fallback': self._handle_fallback,
            'create_missing_file': self._handle_create_missing,
            'skip_git_analysis': self._handle_skip_git,
            'request_permission_fix': self._handle_permission_issue,
            'retry_with_elevated_permissions': self._handle_elevated_retry
        }
        
        handler = handlers.get(strategy, self._handle_default)
        return handler(error, context)
    
    def _handle_retry(self, error: Exception, context: dict) -> dict:
        """é‡è¯•å¤„ç†"""
        operation = context.get('operation')
        max_attempts = self.config.get('retry_attempts', 3)
        
        for attempt in range(max_attempts):
            try:
                self.logger.info(f"é‡è¯•æ“ä½œ {operation} (ç¬¬{attempt + 1}æ¬¡)")
                
                # ç­‰å¾…ä¸€æ®µæ—¶é—´å†é‡è¯•
                if attempt > 0:
                    time.sleep(self.config.get('retry_delay', 2) * attempt)
                
                # é‡æ–°æ‰§è¡Œæ“ä½œ
                result = self._retry_operation(operation, context)
                
                self.error_stats['recovery_successes'] += 1
                return {
                    'success': True,
                    'result': result,
                    'attempts': attempt + 1,
                    'message': f'æ“ä½œåœ¨ç¬¬{attempt + 1}æ¬¡å°è¯•åæˆåŠŸ'
                }
                
            except Exception as retry_error:
                if attempt == max_attempts - 1:
                    # æœ€åä¸€æ¬¡å°è¯•ä»ç„¶å¤±è´¥
                    self.error_stats['recovery_failures'] += 1
                    return {
                        'success': False,
                        'error': str(retry_error),
                        'attempts': max_attempts,
                        'message': f'é‡è¯•{max_attempts}æ¬¡åä»ç„¶å¤±è´¥'
                    }
                continue
    
    def _handle_skip(self, error: Exception, context: dict) -> dict:
        """è·³è¿‡å¤„ç†"""
        operation = context.get('operation', 'unknown')
        self.logger.warning(f"è·³è¿‡æ“ä½œ: {operation} - {str(error)}")
        
        return {
            'success': True,
            'skipped': True,
            'reason': str(error),
            'message': f'å·²è·³è¿‡æ“ä½œ {operation}ï¼Œç³»ç»Ÿç»§ç»­è¿è¡Œ'
        }
    
    def _handle_fallback(self, error: Exception, context: dict) -> dict:
        """é™çº§å¤„ç†"""
        return self.fallback_handler.execute_fallback(error, context)
    
    def _handle_create_missing(self, error: Exception, context: dict) -> dict:
        """åˆ›å»ºç¼ºå¤±æ–‡ä»¶"""
        missing_file = context.get('file_path')
        if not missing_file:
            return {'success': False, 'error': 'æ— æ³•ç¡®å®šç¼ºå¤±çš„æ–‡ä»¶è·¯å¾„'}
        
        try:
            # åˆ›å»ºç›®å½•ç»“æ„
            os.makedirs(os.path.dirname(missing_file), exist_ok=True)
            
            # åˆ›å»ºåŸºæœ¬æ–‡ä»¶å†…å®¹
            default_content = self._get_default_file_content(missing_file)
            with open(missing_file, 'w', encoding='utf-8') as f:
                f.write(default_content)
            
            self.logger.info(f"å·²åˆ›å»ºç¼ºå¤±æ–‡ä»¶: {missing_file}")
            return {
                'success': True,
                'created_file': missing_file,
                'message': 'ç¼ºå¤±æ–‡ä»¶å·²åˆ›å»ºï¼Œæ“ä½œç»§ç»­'
            }
            
        except Exception as create_error:
            self.logger.error(f"åˆ›å»ºæ–‡ä»¶å¤±è´¥: {str(create_error)}")
            return {
                'success': False,
                'error': str(create_error),
                'message': 'æ— æ³•åˆ›å»ºç¼ºå¤±æ–‡ä»¶ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ'
            }
    
    def _handle_skip_git(self, error: Exception, context: dict) -> dict:
        """è·³è¿‡Gitåˆ†æ"""
        self.logger.warning("é¡¹ç›®ä¸æ˜¯Gitä»“åº“ï¼Œè·³è¿‡Gitç›¸å…³åˆ†æ")
        
        # è¿”å›ç©ºçš„Gitåˆ†æç»“æœ
        empty_git_result = {
            'commits': {'total_count': 0, 'completed_tasks': []},
            'file_changes': {'total_files_changed': 0},
            'metrics': {'commits_count': 0, 'last_commit_time': None}
        }
        
        return {
            'success': True,
            'git_analysis': empty_git_result,
            'message': 'éGité¡¹ç›®ï¼Œå·²è·³è¿‡Gitåˆ†æ'
        }


class RetryManager:
    """é‡è¯•ç®¡ç†å™¨ - æ™ºèƒ½é‡è¯•ç­–ç•¥"""
    
    def __init__(self, config: dict):
        self.config = config
        self.logger = self._setup_logger()
    
    def execute_with_retry(self, func: callable, context: dict, max_attempts: int = None) -> any:
        """
        å¸¦é‡è¯•çš„å‡½æ•°æ‰§è¡Œ
        
        Args:
            func: è¦æ‰§è¡Œçš„å‡½æ•°
            context: æ‰§è¡Œä¸Šä¸‹æ–‡
            max_attempts: æœ€å¤§é‡è¯•æ¬¡æ•°
            
        Returns:
            å‡½æ•°æ‰§è¡Œç»“æœ
        """
        max_attempts = max_attempts or self.config.get('retry_attempts', 3)
        base_delay = self.config.get('retry_delay', 2)
        
        for attempt in range(max_attempts):
            try:
                result = func(**context)
                if attempt > 0:
                    self.logger.info(f"æ“ä½œåœ¨ç¬¬{attempt + 1}æ¬¡å°è¯•åæˆåŠŸ")
                return result
                
            except Exception as e:
                if attempt == max_attempts - 1:
                    # æœ€åä¸€æ¬¡å°è¯•ï¼ŒæŠ›å‡ºå¼‚å¸¸
                    raise e
                
                # è®¡ç®—é€€é¿å»¶è¿Ÿ (æŒ‡æ•°é€€é¿)
                delay = base_delay * (2 ** attempt)
                self.logger.warning(f"ç¬¬{attempt + 1}æ¬¡å°è¯•å¤±è´¥ï¼Œ{delay}ç§’åé‡è¯•: {str(e)}")
                time.sleep(delay)
    
    def should_retry(self, error: Exception, attempt: int) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
        # æŸäº›é”™è¯¯ç±»å‹ä¸åº”è¯¥é‡è¯•
        non_retryable_errors = [
            FileNotFoundError,  # æ–‡ä»¶ä¸å­˜åœ¨é€šå¸¸éœ€è¦åˆ›å»ºè€Œä¸æ˜¯é‡è¯•
            PermissionError,    # æƒé™é—®é¢˜éœ€è¦æ‰‹åŠ¨è§£å†³
            KeyboardInterrupt,  # ç”¨æˆ·ä¸­æ–­
            SystemExit          # ç³»ç»Ÿé€€å‡º
        ]
        
        if any(isinstance(error, err_type) for err_type in non_retryable_errors):
            return False
        
        max_attempts = self.config.get('retry_attempts', 3)
        return attempt < max_attempts


class FallbackHandler:
    """é™çº§å¤„ç†å™¨ - æä¾›å¤‡ç”¨æ–¹æ¡ˆ"""
    
    def __init__(self, config: dict):
        self.config = config
        self.logger = self._setup_logger()
    
    def execute_fallback(self, error: Exception, context: dict) -> dict:
        """æ‰§è¡Œé™çº§æ–¹æ¡ˆ"""
        operation = context.get('operation', 'unknown')
        
        fallback_strategies = {
            'git_analysis': self._fallback_git_analysis,
            'file_analysis': self._fallback_file_analysis,
            'progress_calculation': self._fallback_progress_calculation,
            'status_generation': self._fallback_status_generation
        }
        
        strategy = fallback_strategies.get(operation, self._default_fallback)
        return strategy(error, context)
    
    def _fallback_git_analysis(self, error: Exception, context: dict) -> dict:
        """Gitåˆ†æé™çº§æ–¹æ¡ˆ"""
        self.logger.info("ä½¿ç”¨Gitåˆ†æé™çº§æ–¹æ¡ˆ")
        
        # åŸºäºæ–‡ä»¶æ—¶é—´æˆ³çš„ç®€å•åˆ†æ
        project_path = context.get('project_path')
        if not project_path:
            return {'success': False, 'error': 'æ— é¡¹ç›®è·¯å¾„'}
        
        try:
            recent_files = []
            for root, dirs, files in os.walk(project_path):
                dirs[:] = [d for d in dirs if not d.startswith('.')]
                for file in files:
                    if not file.startswith('.'):
                        file_path = os.path.join(root, file)
                        mtime = os.path.getmtime(file_path)
                        if time.time() - mtime < 24 * 3600:  # æœ€è¿‘24å°æ—¶
                            recent_files.append({
                                'path': file_path,
                                'modified': datetime.fromtimestamp(mtime)
                            })
            
            return {
                'success': True,
                'fallback_analysis': {
                    'recent_files': recent_files,
                    'activity_detected': len(recent_files) > 0,
                    'method': 'file_timestamp_analysis'
                },
                'message': 'å·²ä½¿ç”¨æ–‡ä»¶æ—¶é—´æˆ³åˆ†ææ›¿ä»£Gitåˆ†æ'
            }
            
        except Exception as fallback_error:
            return {
                'success': False,
                'error': str(fallback_error),
                'message': 'é™çº§æ–¹æ¡ˆä¹Ÿæ‰§è¡Œå¤±è´¥'
            }
    
    def _fallback_progress_calculation(self, error: Exception, context: dict) -> dict:
        """è¿›åº¦è®¡ç®—é™çº§æ–¹æ¡ˆ"""
        self.logger.info("ä½¿ç”¨è¿›åº¦è®¡ç®—é™çº§æ–¹æ¡ˆ")
        
        # åŸºäºæ–‡ä»¶æ•°é‡å’Œæ—¶é—´çš„ç®€å•ä¼°ç®—
        try:
            project_path = context.get('project_path')
            total_files = 0
            code_files = 0
            
            for root, dirs, files in os.walk(project_path):
                dirs[:] = [d for d in dirs if not d.startswith('.')]
                total_files += len(files)
                code_files += len([f for f in files if any(f.endswith(ext) for ext in ['.py', '.js', '.md'])])
            
            # ç®€å•çš„è¿›åº¦ä¼°ç®—
            estimated_progress = min((code_files / max(total_files * 0.3, 1)) * 100, 100)
            
            return {
                'success': True,
                'fallback_progress': {
                    'overall_percentage': estimated_progress,
                    'total_files': total_files,
                    'code_files': code_files,
                    'method': 'file_count_estimation'
                },
                'message': 'å·²ä½¿ç”¨æ–‡ä»¶ç»Ÿè®¡æ–¹æ³•ä¼°ç®—è¿›åº¦'
            }
            
        except Exception as fallback_error:
            return {
                'success': False,
                'error': str(fallback_error),
                'fallback_progress': {'overall_percentage': 50}  # é»˜è®¤å€¼
            }
    
    def _fallback_status_generation(self, error: Exception, context: dict) -> dict:
        """çŠ¶æ€ç”Ÿæˆé™çº§æ–¹æ¡ˆ"""
        self.logger.info("ä½¿ç”¨çŠ¶æ€ç”Ÿæˆé™çº§æ–¹æ¡ˆ")
        
        # ç”Ÿæˆæœ€åŸºæœ¬çš„çŠ¶æ€æ–‡æ¡£
        project_path = context.get('project_path', '')
        project_name = os.path.basename(project_path) if project_path else 'Unknown Project'
        
        basic_status = f"""# ğŸ“Š é¡¹ç›®çŠ¶æ€æŠ¥å‘Š - {project_name}

> **æœ€åæ›´æ–°**: {datetime.now().strftime('%Y-%m-%d %H:%M')}  
> **æ›´æ–°æ–¹å¼**: åº”æ€¥ç”Ÿæˆ  
> **çŠ¶æ€**: âš ï¸ ç³»ç»Ÿå¼‚å¸¸ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ

## âš ï¸ ç³»ç»Ÿé€šçŸ¥
é¡¹ç›®çŠ¶æ€è‡ªåŠ¨åˆ†æé‡åˆ°é—®é¢˜ï¼Œå½“å‰ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬æŠ¥å‘Šã€‚

**é”™è¯¯ä¿¡æ¯**: {str(error)}

## ğŸ“‹ æ‰‹åŠ¨æ“ä½œå»ºè®®
1. æ£€æŸ¥é¡¹ç›®ç›®å½•æƒé™å’Œå®Œæ•´æ€§
2. éªŒè¯Gitä»“åº“çŠ¶æ€ï¼ˆå¦‚é€‚ç”¨ï¼‰
3. æ‰‹åŠ¨æ›´æ–°é¡¹ç›®çŠ¶æ€ä¿¡æ¯
4. è”ç³»æŠ€æœ¯æ”¯æŒè§£å†³åˆ†æé—®é¢˜

## ğŸ’¡ ä¸´æ—¶è§£å†³æ–¹æ¡ˆ
- å¯ä»¥æ‰‹åŠ¨ç¼–è¾‘æ­¤æ–‡ä»¶æ·»åŠ é¡¹ç›®ä¿¡æ¯
- ç³»ç»Ÿä¼šåœ¨é—®é¢˜è§£å†³åæ¢å¤è‡ªåŠ¨åˆ†æ

---
**ğŸ“ å¤‡æ³¨**: æ­¤æ–‡æ¡£ç”±åº”æ€¥é™çº§ç³»ç»Ÿç”Ÿæˆ  
**ğŸ”§ æ¢å¤**: è¯·è§£å†³ä¸Šè¿°é”™è¯¯åé‡æ–°è¿è¡ŒçŠ¶æ€æ›´æ–°
"""
        
        return {
            'success': True,
            'status_content': basic_status,
            'message': 'å·²ç”Ÿæˆåº”æ€¥çŠ¶æ€æ–‡æ¡£'
        }


class SystemHealthMonitor:
    """ç³»ç»Ÿå¥åº·ç›‘æ§å™¨ - ç›‘æ§è‡ªåŠ¨åŒ–ç³»ç»ŸçŠ¶æ€"""
    
    def __init__(self):
        self.logger = self._setup_logger()
        self.health_metrics = {
            'last_successful_run': None,
            'consecutive_failures': 0,
            'error_rate': 0.0,
            'system_load': 0.0
        }
    
    def check_system_health(self) -> dict:
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        health_status = {
            'overall_status': 'healthy',
            'components': {},
            'warnings': [],
            'errors': [],
            'recommendations': []
        }
        
        # 1. æ£€æŸ¥ç£ç›˜ç©ºé—´
        disk_status = self._check_disk_space()
        health_status['components']['disk'] = disk_status
        if disk_status['status'] != 'healthy':
            health_status['warnings'].append("ç£ç›˜ç©ºé—´ä¸è¶³")
        
        # 2. æ£€æŸ¥æƒé™
        permission_status = self._check_permissions()
        health_status['components']['permissions'] = permission_status
        if permission_status['status'] != 'healthy':
            health_status['errors'].append("æ–‡ä»¶æƒé™é—®é¢˜")
        
        # 3. æ£€æŸ¥ä¾èµ–
        dependency_status = self._check_dependencies()
        health_status['components']['dependencies'] = dependency_status
        if dependency_status['status'] != 'healthy':
            health_status['errors'].append("ä¾èµ–åŒ…ç¼ºå¤±æˆ–ç‰ˆæœ¬ä¸å…¼å®¹")
        
        # 4. è®¡ç®—æ•´ä½“çŠ¶æ€
        if health_status['errors']:
            health_status['overall_status'] = 'critical'
        elif health_status['warnings']:
            health_status['overall_status'] = 'warning'
        
        return health_status
    
    def _check_disk_space(self) -> dict:
        """æ£€æŸ¥ç£ç›˜ç©ºé—´"""
        try:
            import shutil
            total, used, free = shutil.disk_usage("/")
            free_gb = free // (1024**3)
            
            if free_gb < 1:
                status = 'critical'
            elif free_gb < 5:
                status = 'warning'
            else:
                status = 'healthy'
            
            return {
                'status': status,
                'free_gb': free_gb,
                'usage_percent': (used / total) * 100
            }
            
        except Exception as e:
            return {'status': 'error', 'error': str(e)}
    
    def auto_recovery(self, error_info: dict) -> dict:
        """è‡ªåŠ¨æ¢å¤å°è¯•"""
        recovery_actions = []
        
        # 1. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if error_info.get('error_type') == 'disk_space':
            recovery_actions.append(self._cleanup_temp_files())
        
        # 2. é‡ç½®é…ç½®æ–‡ä»¶
        if error_info.get('error_type') == 'config_error':
            recovery_actions.append(self._reset_config())
        
        # 3. é‡å¯æœåŠ¡
        if error_info.get('consecutive_failures', 0) > 3:
            recovery_actions.append(self._restart_services())
        
        return {
            'recovery_attempted': True,
            'actions': recovery_actions,
            'timestamp': datetime.now().isoformat()
        }
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†

### æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

#### PerformanceManager ç±»è®¾è®¡
```python
class PerformanceManager:
    """æ€§èƒ½ç®¡ç†å™¨ - ç›‘æ§å’Œä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½"""
    
    def __init__(self):
        self.logger = self._setup_logger()
        self.metrics_collector = MetricsCollector()
        self.resource_monitor = ResourceMonitor()
        
    def optimize_operation(self, operation_name: str, context: dict) -> dict:
        """ä¼˜åŒ–ç‰¹å®šæ“ä½œçš„æ€§èƒ½"""
        optimizations = {
            'git_analysis': self._optimize_git_analysis,
            'file_scanning': self._optimize_file_scanning,
            'progress_calculation': self._optimize_progress_calculation,
            'status_generation': self._optimize_status_generation
        }
        
        optimizer = optimizations.get(operation_name, self._default_optimization)
        return optimizer(context)
    
    def _optimize_git_analysis(self, context: dict) -> dict:
        """ä¼˜åŒ–Gitåˆ†ææ€§èƒ½"""
        optimizations = []
        
        # 1. é™åˆ¶åˆ†æçš„æäº¤æ•°é‡
        if context.get('commits_count', 0) > 100:
            context['max_commits'] = 100
            optimizations.append("é™åˆ¶åˆ†ææœ€è¿‘100ä¸ªæäº¤")
        
        # 2. å¹¶è¡Œå¤„ç†å¤šä¸ªåˆ†æä»»åŠ¡
        if context.get('enable_parallel', True):
            context['parallel_analysis'] = True
            optimizations.append("å¯ç”¨å¹¶è¡Œåˆ†æ")
        
        # 3. ç¼“å­˜Gitå¯¹è±¡
        context['use_git_cache'] = True
        optimizations.append("å¯ç”¨Gitå¯¹è±¡ç¼“å­˜")
        
        return {
            'optimized': True,
            'optimizations': optimizations,
            'context': context
        }
    
    def monitor_resource_usage(self) -> dict:
        """ç›‘æ§èµ„æºä½¿ç”¨æƒ…å†µ"""
        return self.resource_monitor.get_current_usage()


class ResourceMonitor:
    """èµ„æºç›‘æ§å™¨"""
    
    def get_current_usage(self) -> dict:
        """è·å–å½“å‰èµ„æºä½¿ç”¨æƒ…å†µ"""
        try:
            import psutil
            
            return {
                'cpu_percent': psutil.cpu_percent(interval=1),
                'memory_percent': psutil.virtual_memory().percent,
                'disk_usage': psutil.disk_usage('/').percent,
                'load_average': os.getloadavg() if hasattr(os, 'getloadavg') else None
            }
            
        except ImportError:
            # å¦‚æœpsutilä¸å¯ç”¨ï¼Œä½¿ç”¨åŸºç¡€æ–¹æ³•
            return {
                'cpu_percent': 0,
                'memory_percent': 0,
                'disk_usage': 0,
                'note': 'psutilæœªå®‰è£…ï¼Œæ— æ³•è·å–è¯¦ç»†èµ„æºä¿¡æ¯'
            }
```

## ğŸ”§ å®æ–½å»ºè®®å’Œæœ€ä½³å®è·µ

### éƒ¨ç½²æ­¥éª¤å’Œæœ€ä½³å®è·µ

#### 1. ç³»ç»Ÿéƒ¨ç½²å»ºè®®
```bash
# 1. ç¯å¢ƒå‡†å¤‡
# ç¡®ä¿Python 3.8+ç¯å¢ƒ
python3 --version

# å®‰è£…ç³»ç»Ÿä¾èµ–
pip install gitpython schedule watchdog pyyaml jinja2 psutil

# 2. åˆ›å»ºç³»ç»Ÿç›®å½•ç»“æ„
mkdir -p ~/.personal-manager/{scripts,config,logs,templates,data}

# 3. é…ç½®æ–‡ä»¶è®¾ç½®
cp config/automation.yaml ~/.personal-manager/config/
cp templates/*.j2 ~/.personal-manager/templates/

# 4. æƒé™è®¾ç½®
chmod +x scripts/*.py
chmod 755 ~/.personal-manager/scripts/

# 5. æµ‹è¯•å®‰è£…
pm-automation --version
pm-automation init --dry-run
```

#### 2. é…ç½®æœ€ä½³å®è·µ

**è‡ªåŠ¨åŒ–é…ç½®ä¼˜åŒ–**ï¼š
```yaml
# ~/.personal-manager/config/automation.yaml
git_hooks:
  post_commit_enabled: true      # æ¨èå¯ç”¨
  pre_push_enabled: false        # æ ¹æ®éœ€è¦å¯ç”¨
  hook_timeout: 30               # é˜²æ­¢é˜»å¡Gitæ“ä½œ
  async_execution: true          # å¼‚æ­¥æ‰§è¡Œé¿å…å»¶è¿Ÿ

scheduled_tasks:
  daily_summary_enabled: true
  daily_summary_time: "18:00"    # å»ºè®®å·¥ä½œç»“æŸæ—¶é—´
  weekly_analysis_enabled: true
  weekly_analysis_time: "20:00"  # å‘¨æœ«æ€»ç»“æ—¶é—´
  health_check_enabled: true
  health_check_time: "09:00"     # å·¥ä½œå¼€å§‹å‰æ£€æŸ¥

file_watchers:
  enabled: false                 # é»˜è®¤ç¦ç”¨ï¼Œæ€§èƒ½å½±å“å¤§
  file_patterns: ["*.py", "*.js", "*.md"]
  debounce_seconds: 30           # é˜²æ­¢é¢‘ç¹è§¦å‘
  watch_depth: 3                 # é™åˆ¶ç›‘æ§ç›®å½•æ·±åº¦

performance:
  max_commits_analysis: 100      # é™åˆ¶Gitåˆ†æèŒƒå›´
  parallel_processing: true      # å¯ç”¨å¹¶è¡Œå¤„ç†
  cache_enabled: true            # å¯ç”¨ç»“æœç¼“å­˜
  timeout_seconds: 120           # æ“ä½œè¶…æ—¶æ—¶é—´

error_handling:
  retry_attempts: 3              # é‡è¯•æ¬¡æ•°
  retry_delay: 2                 # é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰
  fallback_enabled: true         # å¯ç”¨é™çº§å¤„ç†
  notification_enabled: true     # å¯ç”¨é”™è¯¯é€šçŸ¥
  log_level: "INFO"              # æ—¥å¿—çº§åˆ«
```

#### 3. é¡¹ç›®ç±»å‹ç‰¹åŒ–é…ç½®

**ç¼–ç¨‹é¡¹ç›®é…ç½®**ï¼š
```yaml
project_types:
  coding:
    progress_weights:
      code_completion: 0.4       # ä»£ç å®Œæˆåº¦æƒé‡
      todo_completion: 0.2       # TODOå®Œæˆæƒé‡
      test_coverage: 0.2         # æµ‹è¯•è¦†ç›–æƒé‡
      documentation: 0.1         # æ–‡æ¡£å®Œæˆæƒé‡
      git_activity: 0.1          # Gitæ´»åŠ¨æƒé‡
    
    file_patterns:
      code_files: ["*.py", "*.js", "*.ts", "*.java", "*.cpp"]
      test_files: ["*test*.py", "*spec*.js", "test_*.py"]
      doc_files: ["README.md", "*.rst", "docs/*.md"]
    
    milestones:
      - "é¡¹ç›®åˆå§‹åŒ–å®Œæˆ"
      - "æ ¸å¿ƒåŠŸèƒ½å¼€å‘å®Œæˆ"
      - "æµ‹è¯•è¦†ç›–è¾¾æ ‡"
      - "æ–‡æ¡£å®Œå–„"
      - "å‘å¸ƒå‡†å¤‡å°±ç»ª"
```

**å­¦ä¹ é¡¹ç›®é…ç½®**ï¼š
```yaml
project_types:
  learning:
    progress_weights:
      material_completion: 0.5   # å­¦ä¹ ææ–™å®Œæˆåº¦
      exercise_completion: 0.3   # ç»ƒä¹ å®Œæˆåº¦
      note_quality: 0.2          # ç¬”è®°è´¨é‡
    
    file_patterns:
      note_files: ["*.md", "*.txt"]
      exercise_files: ["exercise_*.py", "homework_*.js"]
      resource_files: ["*.pdf", "*.epub"]
    
    learning_metrics:
      daily_study_target: 60     # æ¯æ—¥å­¦ä¹ ç›®æ ‡ï¼ˆåˆ†é’Ÿï¼‰
      weekly_review: true        # æ¯å‘¨å¤ä¹ 
      progress_tracking: "percentage"  # è¿›åº¦è·Ÿè¸ªæ–¹å¼
```

#### 4. æ€§èƒ½ä¼˜åŒ–å»ºè®®

**Gitåˆ†æä¼˜åŒ–**ï¼š
```python
# ä¼˜åŒ–é…ç½®ç¤ºä¾‹
git_optimization = {
    'shallow_clone_depth': 50,      # æµ…å…‹éš†æ·±åº¦
    'ignore_merge_commits': True,   # å¿½ç•¥åˆå¹¶æäº¤
    'batch_processing': True,       # æ‰¹é‡å¤„ç†
    'incremental_analysis': True,   # å¢é‡åˆ†æ
    'cache_duration': 3600         # ç¼“å­˜1å°æ—¶
}
```

**æ–‡ä»¶æ‰«æä¼˜åŒ–**ï¼š
```python
# æ–‡ä»¶æ‰«æä¼˜åŒ–
file_scan_optimization = {
    'max_file_size': 10 * 1024 * 1024,  # æœ€å¤§æ–‡ä»¶å¤§å°10MB
    'exclude_patterns': [
        '*/node_modules/*',
        '*/.git/*',
        '*/venv/*',
        '*/__pycache__/*'
    ],
    'parallel_scanning': True,           # å¹¶è¡Œæ‰«æ
    'scan_timeout': 30                   # æ‰«æè¶…æ—¶
}
```

#### 5. ç›‘æ§å’Œè¿ç»´

**æ—¥å¿—é…ç½®**ï¼š
```python
logging_config = {
    'version': 1,
    'formatters': {
        'detailed': {
            'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        }
    },
    'handlers': {
        'file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '~/.personal-manager/logs/automation.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 5,
            'formatter': 'detailed'
        }
    },
    'root': {
        'level': 'INFO',
        'handlers': ['file']
    }
}
```

**å¥åº·æ£€æŸ¥è„šæœ¬**ï¼š
```bash
#!/bin/bash
# health-check.sh - ç³»ç»Ÿå¥åº·æ£€æŸ¥è„šæœ¬

echo "ğŸ” PersonalManager å¥åº·æ£€æŸ¥"
echo "================================"

# 1. æ£€æŸ¥æœåŠ¡çŠ¶æ€
echo "ğŸ“Š æ£€æŸ¥æœåŠ¡çŠ¶æ€..."
pm-automation status

# 2. æ£€æŸ¥ç£ç›˜ç©ºé—´
echo "ğŸ’¾ æ£€æŸ¥ç£ç›˜ç©ºé—´..."
df -h ~/.personal-manager

# 3. æ£€æŸ¥æ—¥å¿—æ–‡ä»¶
echo "ğŸ“‹ æ£€æŸ¥æœ€è¿‘é”™è¯¯..."
tail -n 20 ~/.personal-manager/logs/automation.log | grep ERROR

# 4. æ£€æŸ¥é…ç½®æ–‡ä»¶
echo "âš™ï¸ éªŒè¯é…ç½®æ–‡ä»¶..."
pm-automation config --validate

# 5. æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½
echo "ğŸ§ª æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½..."
pm-automation test --quick

echo "âœ… å¥åº·æ£€æŸ¥å®Œæˆ"
```

#### 6. æ•…éšœæ’é™¤æŒ‡å—

**å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ**ï¼š

1. **Git Hookä¸å·¥ä½œ**
   ```bash
   # æ£€æŸ¥hookæ–‡ä»¶æƒé™
   ls -la .git/hooks/post-commit
   chmod +x .git/hooks/post-commit
   
   # æµ‹è¯•hookè„šæœ¬
   bash -n .git/hooks/post-commit
   ```

2. **æƒé™é”™è¯¯**
   ```bash
   # ä¿®å¤æ–‡ä»¶æƒé™
   chmod -R 755 ~/.personal-manager/
   chown -R $USER ~/.personal-manager/
   ```

3. **Pythonä¾èµ–é—®é¢˜**
   ```bash
   # é‡æ–°å®‰è£…ä¾èµ–
   pip install --upgrade gitpython schedule watchdog
   
   # æ£€æŸ¥Pythonè·¯å¾„
   which python3
   ```

4. **æ€§èƒ½é—®é¢˜**
   ```bash
   # æ¸…ç†ç¼“å­˜
   rm -rf ~/.personal-manager/cache/*
   
   # å‡å°‘åˆ†æèŒƒå›´
   pm-automation config set git.max_commits 50
   ```

#### 7. å‡çº§å’Œç»´æŠ¤

**ç‰ˆæœ¬å‡çº§æµç¨‹**ï¼š
```bash
# 1. å¤‡ä»½é…ç½®
cp ~/.personal-manager/config/automation.yaml ~/backup/

# 2. åœæ­¢æœåŠ¡
pm-automation stop

# 3. æ›´æ–°ä»£ç 
git pull origin main
pip install --upgrade -r requirements.txt

# 4. è¿ç§»é…ç½®
pm-automation config migrate

# 5. é‡å¯æœåŠ¡
pm-automation start

# 6. éªŒè¯åŠŸèƒ½
pm-automation test
```

**å®šæœŸç»´æŠ¤ä»»åŠ¡**ï¼š
```bash
# æ¯å‘¨æ‰§è¡Œçš„ç»´æŠ¤è„šæœ¬
#!/bin/bash
# weekly-maintenance.sh

echo "ğŸ§¹ æ‰§è¡Œå‘¨åº¦ç»´æŠ¤..."

# 1. æ¸…ç†æ—§æ—¥å¿—
find ~/.personal-manager/logs/ -name "*.log.*" -mtime +30 -delete

# 2. æ¸…ç†ç¼“å­˜
find ~/.personal-manager/cache/ -mtime +7 -delete

# 3. å¤‡ä»½é…ç½®
tar -czf ~/backups/pm-config-$(date +%Y%m%d).tar.gz ~/.personal-manager/config/

# 4. ç³»ç»Ÿå¥åº·æ£€æŸ¥
pm-automation health-check --detailed

# 5. æ›´æ–°ç»Ÿè®¡æŠ¥å‘Š
pm-automation generate-report --weekly

echo "âœ… ç»´æŠ¤å®Œæˆ"
```

## ğŸ“‹ éªŒæ”¶æ ‡å‡†æ£€æŸ¥

### å®Œæ•´æ€§éªŒè¯

âœ… **è„šæœ¬è®¾è®¡å®Œæ•´æ€§**
- [x] Gitæ´»åŠ¨åˆ†æè„šæœ¬æœ‰å®Œæ•´çš„ä¼ªä»£ç å’Œå®ç°æ€è·¯
- [x] é¡¹ç›®è¿›åº¦è®¡ç®—ç®—æ³•æœ‰å…·ä½“çš„è®¡ç®—å…¬å¼å’Œå¤šç»´åº¦åˆ†æ
- [x] è‡ªåŠ¨åŒ–è§¦å‘æœºåˆ¶åŒ…å«Git hooksã€å®šæ—¶ä»»åŠ¡ã€æ–‡ä»¶ç›‘æ§
- [x] çŠ¶æ€æ–‡æ¡£ç”Ÿæˆé€»è¾‘æ”¯æŒæ¨¡æ¿åŒ–å’Œæ™ºèƒ½åˆå¹¶
- [x] é”™è¯¯å¤„ç†æœºåˆ¶åŒ…å«é‡è¯•ã€é™çº§ã€æ¢å¤ç­–ç•¥
- [x] æ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†æœ‰å…·ä½“å®ç°æ–¹æ¡ˆ

âœ… **æŠ€æœ¯å®ç°ç»†èŠ‚**
- [x] æ‰€æœ‰æ ¸å¿ƒç±»éƒ½æœ‰è¯¦ç»†çš„æ–¹æ³•è®¾è®¡å’Œå‚æ•°è¯´æ˜
- [x] Git hooksé…ç½®æœ‰å®Œæ•´çš„å®‰è£…å’Œæµ‹è¯•æ­¥éª¤  
- [x] çŠ¶æ€åˆ†æç®—æ³•æœ‰æ˜ç¡®çš„è®¡ç®—å…¬å¼å’Œæƒé‡è®¾è®¡
- [x] è‡ªåŠ¨åŒ–è§¦å‘æœºåˆ¶ç»è¿‡å¯é æ€§è®¾è®¡å’Œå¼‚å¸¸å¤„ç†
- [x] åŒ…å«å®Œæ•´çš„é”™è¯¯åˆ†ç±»ã€é‡è¯•ç­–ç•¥å’Œé™çº§æ–¹æ¡ˆ
- [x] æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–æœ‰å…·ä½“çš„å®ç°ç­–ç•¥

âœ… **å¯æ“ä½œæ€§ä¿è¯**
- [x] æä¾›å®Œæ•´çš„å®‰è£…è„šæœ¬å’Œé…ç½®æ–‡ä»¶
- [x] åŒ…å«è¯¦ç»†çš„ä½¿ç”¨ç¤ºä¾‹å’Œå‘½ä»¤è¡Œå·¥å…·
- [x] æœ‰å®Œæ•´çš„æ•…éšœæ’é™¤æŒ‡å—å’Œç»´æŠ¤æµç¨‹
- [x] æä¾›æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–å»ºè®®
- [x] åŒ…å«å‡çº§è¿ç§»å’Œç‰ˆæœ¬ç®¡ç†æ–¹æ¡ˆ

---

**ğŸ“Š æ–‡æ¡£æ€»ç»“**  
æœ¬æ–‡æ¡£æä¾›äº†PersonalManageré¡¹ç›®çŠ¶æ€è‡ªåŠ¨åŒ–çš„å®Œæ•´æŠ€æœ¯è®¾è®¡ï¼ŒåŒ…å«6å¤§æ ¸å¿ƒç»„ä»¶ï¼šGitæ´»åŠ¨åˆ†æã€é¡¹ç›®è¿›åº¦è®¡ç®—ã€è‡ªåŠ¨åŒ–è§¦å‘æœºåˆ¶ã€çŠ¶æ€æ–‡æ¡£ç”Ÿæˆã€é”™è¯¯å¤„ç†æ¢å¤ã€æ€§èƒ½ä¼˜åŒ–ç®¡ç†ã€‚è®¾è®¡ç¡®ä¿ç³»ç»Ÿç¨³å®šå¯é ï¼Œèƒ½å¤Ÿå‡†ç¡®åæ˜ é¡¹ç›®å®é™…çŠ¶æ€ï¼Œä¸ºPersonalManagerç³»ç»Ÿæä¾›å¼ºå¤§çš„è‡ªåŠ¨åŒ–æ”¯æŒã€‚

**ğŸ¯ å®æ–½ä»·å€¼**  
é€šè¿‡æœ¬è®¾è®¡å®ç°çš„è‡ªåŠ¨åŒ–ç³»ç»Ÿå°†æ˜¾è‘—å‡å°‘æ‰‹åŠ¨ç»´æŠ¤å·¥ä½œé‡ï¼ˆé¢„è®¡å‡å°‘90%ï¼‰ï¼Œæé«˜é¡¹ç›®çŠ¶æ€ä¿¡æ¯çš„å‡†ç¡®æ€§å’Œå®æ—¶æ€§ï¼Œä¸ºç”¨æˆ·æä¾›å¯é çš„é¡¹ç›®ç®¡ç†æ”¯æŒã€‚

---

*æ–‡æ¡£åˆ›å»ºæ—¶é—´: 2025-09-11*  
*æ–‡æ¡£çŠ¶æ€: è®¾è®¡å®Œæˆ âœ…*  
*éªŒæ”¶æ ‡å‡†: å…¨éƒ¨è¾¾æˆ âœ…*

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u67e5\u9605\u9879\u76ee\u72b6\u6001\u81ea\u52a8\u7ef4\u62a4\u65b9\u6848\u4e2d\u7684Python\u4ee3\u7801", "status": "completed", "activeForm": "\u67e5\u9605\u9879\u76ee\u72b6\u6001\u81ea\u52a8\u7ef4\u62a4\u65b9\u6848\u4e2d\u7684Python\u4ee3\u7801"}, {"content": "\u8bbe\u8ba1Git\u6d3b\u52a8\u5206\u6790\u811a\u672c", "status": "completed", "activeForm": "\u8bbe\u8ba1Git\u6d3b\u52a8\u5206\u6790\u811a\u672c"}, {"content": "\u8bbe\u8ba1\u9879\u76ee\u8fdb\u5ea6\u8ba1\u7b97\u7b97\u6cd5", "status": "in_progress", "activeForm": "\u8bbe\u8ba1\u9879\u76ee\u8fdb\u5ea6\u8ba1\u7b97\u7b97\u6cd5"}, {"content": "\u8bbe\u8ba1\u81ea\u52a8\u5316\u89e6\u53d1\u673a\u5236", "status": "pending", "activeForm": "\u8bbe\u8ba1\u81ea\u52a8\u5316\u89e6\u53d1\u673a\u5236"}, {"content": "\u8bbe\u8ba1\u72b6\u6001\u6587\u6863\u751f\u6210\u903b\u8f91", "status": "pending", "activeForm": "\u8bbe\u8ba1\u72b6\u6001\u6587\u6863\u751f\u6210\u903b\u8f91"}, {"content": "\u8bbe\u8ba1\u9519\u8bef\u5904\u7406\u548c\u6062\u590d\u673a\u5236", "status": "pending", "activeForm": "\u8bbe\u8ba1\u9519\u8bef\u5904\u7406\u548c\u6062\u590d\u673a\u5236"}, {"content": "\u521b\u5efa\u81ea\u52a8\u5316\u811a\u672c\u8bbe\u8ba1\u6587\u6863", "status": "pending", "activeForm": "\u521b\u5efa\u81ea\u52a8\u5316\u811a\u672c\u8bbe\u8ba1\u6587\u6863"}]