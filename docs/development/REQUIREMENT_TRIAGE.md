# PersonalManager 需求筛选与分类机制

> **目的**: 在任何开发活动之前，智能判断用户需求的真实性质，避免功能重复开发和过度工程化。

---

## 🔍 需求筛选流程图

```
用户表达需求
       ↓
   【第一步】现有功能探索
       ↓
   是否已有解决方案？
   ↙️         ↘️
 【有】        【无】
引导使用      【第二步】需求性质判断
             ↓
         是开发需求吗？
         ↙️         ↘️
       【是】        【否】
   【第三步】      提供配置/
   开发类型判断    使用指导
   ↓
临时解决 vs 持久化开发
```

---

## 🎯 第一步：现有功能探索

### 1.1 系统功能库存检查清单

当用户提出需求时，**必须**按以下顺序进行功能探索：

#### A. CLI命令完整检查
```bash
# 1. 检查主命令帮助
./bin/pm-local --help

# 2. 检查各模块命令
./bin/pm-local gtd --help
./bin/pm-local habits --help
./bin/pm-local deepwork --help
./bin/pm-local ai --help
./bin/pm-local auth --help
./bin/pm-local privacy --help

# 3. 检查隐藏或不常用命令
./bin/pm-local calendar --help
./bin/pm-local gmail --help
./bin/pm-local tasks --help
```

#### B. 脚本库存检查
```bash
# 检查所有可用脚本
ls -la scripts/
```

当前可用脚本：
- `sync_habits_to_tasks.py` - 习惯同步到Google Tasks
- `sync_habits_to_obsidian.py` - 习惯数据同步到Obsidian
- `sync_projects_to_obsidian.py` - 项目状态同步
- `clean_old_habit_tasks.py` - 清理旧习惯任务

#### C. 配置和数据结构检查
```bash
# 检查现有数据结构
ls -la ~/.personalmanager/data/
cat ~/.personalmanager/data/habits/habits.json
ls -la ~/.personalmanager/data/gtd/
```

#### D. 集成功能检查
- Google服务：Calendar, Tasks, Gmail
- Obsidian集成状态
- AI服务集成：Claude, Gemini
- 自动化任务：Crontab配置

### 1.2 功能探索输出模板

```markdown
## 现有功能探索结果

### CLI命令检查
- [ ] 主命令系统：已检查，结果：[结果]
- [ ] GTD模块：已检查，结果：[结果]
- [ ] 习惯模块：已检查，结果：[结果]
- [ ] 其他模块：已检查，结果：[结果]

### 脚本资源检查
- [ ] 现有脚本：已检查，相关脚本：[列表]
- [ ] 自动化任务：已检查，相关任务：[列表]

### 数据和配置检查
- [ ] 数据结构：已检查，现有数据：[描述]
- [ ] 配置状态：已检查，相关配置：[描述]

### 集成服务检查
- [ ] Google服务：已检查，可用功能：[列表]
- [ ] Obsidian集成：已检查，可用功能：[列表]
- [ ] AI服务：已检查，可用功能：[列表]

### **结论**
- ✅ **已有完整解决方案**：[具体方案]
- ⚠️ **部分功能存在，需要组合使用**：[组合方案]
- ❌ **无现有解决方案，需要开发**：[开发需求]
```

---

## 🤔 第二步：需求性质判断

### 2.1 需求分类判断表

| 需求表述特征 | 可能的真实需求 | 建议响应 |
|-------------|---------------|----------|
| "我想要..." | 功能使用需求 | 引导现有功能 |
| "怎么..." | 使用方法询问 | 提供使用指导 |
| "能不能..." | 功能探索询问 | 功能演示 |
| "系统没有..." | 可能功能误解 | 功能探索 + 演示 |
| "每次都要..." | 自动化需求 | 检查现有自动化 |
| "我想改..." | 配置调整需求 | 配置指导 |
| "这个不对..." | 问题报告 | 问题诊断 |
| "新增功能..." | 真实开发需求 | 进入开发流程 |

### 2.2 需求类型分类

#### Type A: 使用指导需求 🟢
**特征**: 用户不熟悉现有功能
**响应策略**:
1. 演示相关功能
2. 提供使用示例
3. 更新文档（如需要）
**无需开发**

#### Type B: 配置调整需求 🟡
**特征**: 需要修改参数、时间、设置等
**响应策略**:
1. 检查现有配置选项
2. 使用现有配置命令
3. 必要时手动修改配置文件
**可能需要轻量级脚本**

#### Type C: 数据操作需求 🟡
**特征**: 查询、清理、导出数据
**响应策略**:
1. 使用现有命令
2. 编写一次性查询脚本
3. 不需要持久化功能
**临时脚本解决**

#### Type D: 自动化需求 🟠
**特征**: 重复性任务自动化
**响应策略**:
1. 检查现有自动化
2. 评估Crontab解决方案
3. 必要时创建专用脚本
**可能需要持久化脚本**

#### Type E: 真实功能开发需求 🔴
**特征**: 系统确实缺少该功能
**响应策略**:
1. 进入完整开发流程
2. 需求分析 → 设计 → 实现
3. 可能需要修改核心代码
**需要正式开发**

---

## ⚡ 第三步：智能响应策略

### 3.1 响应策略决策树

```
需求收到
    ↓
现有功能探索 (30秒-2分钟)
    ↓
功能存在？
    ↓
【YES】→ 直接演示使用，无需开发
    ↓
【NO】→ 需求类型判断
    ↓
Type A/B？→ 配置指导，无需开发
    ↓
Type C？→ 临时脚本，一次性解决
    ↓
Type D？→ 评估自动化方案
    ↓
Type E？→ 进入正式开发流程
```

### 3.2 响应时间和复杂度指标

| 需求类型 | 响应时间 | 复杂度 | 是否需要记录 |
|---------|---------|--------|-------------|
| Type A | <5分钟 | 极低 | 否 |
| Type B | <10分钟 | 低 | 简单记录 |
| Type C | <20分钟 | 中低 | 记录脚本 |
| Type D | <60分钟 | 中等 | 完整记录 |
| Type E | >60分钟 | 高 | 完整开发流程 |

### 3.3 质量检查标准

在任何响应之前问自己：
- [ ] 我是否彻底检查了现有功能？
- [ ] 用户的真实需求是什么（vs表面需求）？
- [ ] 最简单的解决方案是什么？
- [ ] 这个问题是否会再次出现？
- [ ] 我的解决方案是否会创造技术债务？

---

## 📋 实际应用模板

### 需求接收处理模板

```markdown
## 需求处理: [用户需求简述]

### 📝 用户原始表述
"[用户的原话]"

### 🔍 第一步：现有功能探索
**执行时间**: [开始时间]

#### CLI功能检查
- 命令: `[执行的命令]`
- 结果: [检查结果]

#### 脚本检查
- 相关脚本: [找到的相关脚本]

#### 数据/配置检查
- 现有配置: [相关配置]

### 🎯 第二步：需求分类
**分类结果**: Type [A/B/C/D/E]
**判断依据**: [为什么这样分类]

### ⚡ 第三步：响应策略
**选择策略**: [具体策略]
**预估复杂度**: [低/中/高]
**是否需要开发**: [是/否]

### ✅ 执行结果
[具体的解决方案或回答]

### 📊 效果评估
- 解决了用户问题？[是/否]
- 用户满意度：[满意/基本满意/不满意]
- 是否避免了不必要开发？[是/否]
```

---

## 🛡️ 防止过度开发的保护措施

### 3.4 强制检查点

在进行任何代码编写前，必须通过以下检查点：

1. **功能探索检查点** ✋
   - 问题：现有系统是否已有解决方案？
   - 通过条件：已彻底检查所有相关功能

2. **需求合理性检查点** ✋
   - 问题：这真的需要新开发吗？
   - 通过条件：确认无现有方案可组合使用

3. **复杂度评估检查点** ✋
   - 问题：解决方案的复杂度合理吗？
   - 通过条件：选择了最简单的有效方案

4. **持久性评估检查点** ✋
   - 问题：这需要持久化还是一次性解决？
   - 通过条件：评估了复用性和维护成本

### 3.5 自动提醒机制

当检测到以下模式时，自动触发额外审查：
- 用户说"写个脚本"
- 要创建新文件
- 要修改核心代码
- 估计时间超过30分钟

---

## 📈 效果监控

### 成功指标
- **避免重复开发率**: 通过功能探索避免的不必要开发次数
- **需求满足效率**: Type A/B需求的平均解决时间
- **用户满意度**: 用户对响应方案的满意程度
- **系统复杂度控制**: 避免添加不必要的代码和脚本

### 定期评估
- 每周回顾：哪些需求被正确分类？哪些分类错误？
- 每月优化：更新分类标准和响应策略
- 季度总结：整体系统复杂度是否得到控制？

---

**版本**: 1.0
**创建时间**: 2025-09-15 01:20
**维护者**: Claude (PersonalManager AI Assistant)
**下次评估**: 2025-10-15