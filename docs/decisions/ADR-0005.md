# ADR-0005: BMAD命令前缀与PM别名映射策略

## 状态
已接受

## 背景

PersonalManager 基于 BMAD 框架构建，而 BMAD 框架使用 `slashPrefix: BMad` 作为默认命令前缀。随着 PersonalManager 的发展，产品需要建立自己独特的命令空间标识，同时还要考虑与现有 Agent 集成系统的兼容性。

当前面临的关键挑战包括：

1. **品牌一致性需求**: PersonalManager 作为独立产品，需要统一的 `pm` 命令入口来强化品牌认知
2. **向后兼容性**: 现有用户和系统可能依赖 `BMad` 前缀的命令结构
3. **Agent 集成复杂性**: 多个 Agent 子模块需要统一的命令调用接口
4. **用户学习成本**: 避免用户需要记住多套命令前缀的困扰
5. **框架迁移风险**: 完全废弃 BMAD 前缀可能破坏现有集成

技术背景分析：
- BMAD 框架的 slashPrefix 配置深度集成在路由和命令解析层
- PersonalManager 的 CLI 模块已经实现了 `pm` 命令入口
- Agent 系统需要统一的命令调用方式来保证一致性
- 现有文档和示例中混合使用了 BMad 和 pm 两种前缀

## 考虑的方案

### 方案1: 保留 BMad 前缀 + 新增 pm 别名映射（推荐方案）
```bash
# 保留原有 BMAD 命令
BMad project status
BMad task add "新任务"
BMad agent launcher

# 新增 pm 别名，映射到相同功能
pm project status    # 映射到 BMad project status  
pm task add "新任务" # 映射到 BMad task add
pm agent launcher    # 映射到 BMad agent launcher
```

**优点**: 
- 完全向后兼容，不破坏现有用户习惯
- 渐进式迁移，用户可以自然过渡到 pm 命令
- 技术实现风险最小，只需添加别名映射层
- 双品牌共存，满足不同用户群体需求

**缺点**: 
- 维护两套命令前缀增加复杂度
- 文档需要明确说明两种命令的关系
- 可能造成用户混淆，需要清晰的引导策略

### 方案2: 双前缀并行策略
```bash
# BMAD 前缀专用于框架级功能
BMad agent status
BMad framework config
BMad system info

# pm 前缀专用于业务功能  
pm project status
pm task add "新任务"
pm habits track
pm calendar today
```

**优点**:
- 功能边界清晰，框架与业务分离
- 避免命令冲突，职责明确
- 为未来扩展预留清晰的命名空间

**缺点**:
- 用户需要学习并记住两套前缀规则
- 功能边界可能模糊，划分标准难以统一
- 增加用户认知负担，违背简洁性原则

### 方案3: 完全迁移到 pm 前缀
```bash
# 完全废弃 BMad，统一使用 pm
pm project status
pm task add "新任务"  
pm agent launcher
pm framework config
```

**优点**:
- 命令体系最简洁一致
- 品牌统一性最强
- 长期维护成本最低

**缺点**:
- 破坏性变更，可能导致现有用户和系统崩溃
- 需要大规模重构 BMAD 框架的路由系统
- 迁移风险高，可能引入难以预料的错误
- Agent 集成需要全面重新配置

## 决策

选择 **方案1: 保留 BMad 前缀 + 新增 pm 别名映射**，具体实施策略如下：

### 核心设计原则

1. **向后兼容优先**: 所有现有 `BMad` 命令必须持续有效
2. **渐进式迁移**: `pm` 作为推荐入口，但不强制用户迁移
3. **功能对等性**: `pm` 和 `BMad` 命令提供完全相同的功能
4. **文档引导**: 新文档优先展示 `pm` 命令，但保留 `BMad` 参考

### 技术实现策略

#### 别名映射层设计
```python
# 在 CLI 入口层添加命令前缀映射
COMMAND_PREFIX_MAPPING = {
    'pm': 'BMad',  # pm 命令映射到 BMad 实现
}

def route_command(prefix: str, command: str, args: list):
    # 如果是 pm 前缀，映射到 BMad 实现
    if prefix == 'pm':
        actual_prefix = 'BMad'
        return execute_bmad_command(actual_prefix, command, args)
    
    # 保持 BMad 原有路由
    elif prefix == 'BMad':
        return execute_bmad_command(prefix, command, args)
```

#### Agent 集成统一接口
```python
# Agent 系统使用统一的内部调用接口
class AgentCommandInterface:
    def execute(self, command: str, args: dict):
        # 内部统一使用 BMad 实现
        return bmad_framework.execute(command, args)
        
    def get_available_commands(self):
        # 返回 pm 格式的命令列表用于展示
        return format_commands_with_prefix('pm')
```

### 命令优先级策略

1. **用户文档**: 优先展示 `pm` 命令语法
2. **CLI 帮助**: `pm help` 和 `BMad help` 显示相同内容，但样例使用各自前缀
3. **错误提示**: 智能提示，如用户输入错误的 BMad 命令，提示对应的 pm 版本
4. **自动补全**: 支持两种前缀的 Tab 补全

### 渐进迁移路线图

#### 第一阶段 (即时实施)
- 实现 pm 到 BMad 的别名映射
- 更新 CLI 帮助系统支持双前缀
- 在用户指南中引入 pm 命令示例

#### 第二阶段 (1-2个月后)  
- 将所有新文档默认使用 pm 前缀
- 在 BMad 命令执行时添加温和的迁移提示
- 更新 Agent 文档使用 pm 示例

#### 第三阶段 (3-6个月后)
- 设置 pm 为主要推荐入口
- BMad 命令保持支持但标记为"传统模式"
- 用户调研收集迁移反馈

## 结果

### 积极影响

#### 用户体验提升
- **学习成本降低**: 新用户直接学习 pm 命令，无需了解 BMAD 背景
- **品牌一致性**: 强化 PersonalManager 产品认知，提升专业形象  
- **命令简洁性**: `pm` 相比 `BMad` 减少50%字符，提升日常使用效率
- **向后兼容**: 现有用户无需改变习惯，平滑过渡

#### 技术架构优化
- **风险可控**: 别名映射实现简单，技术风险最小
- **维护性**: 核心逻辑保持在 BMAD 层，避免代码重复
- **扩展性**: 为未来完全迁移到 pm 保留技术路径
- **集成友好**: Agent 系统获得统一的调用接口

#### 产品定位强化  
- **品牌独立**: 从 BMAD 框架中建立独立的产品身份
- **市场区分**: 与其他基于 BMAD 的工具形成差异化
- **用户粘性**: 专属命令入口增强用户归属感

### 潜在挑战及应对

#### 用户混淆问题
**挑战**: 用户可能不理解 pm 和 BMad 的关系
**应对**: 
- 在首次使用时显示清晰的说明信息
- 文档中设置专门的"命令前缀说明"章节
- CLI help 显示两种前缀的对应关系

#### 维护复杂度
**挑战**: 需要维护两套命令前缀的文档和测试
**应对**: 
- 使用自动化工具生成双前缀文档
- 建立命令映射测试套件
- 设置CI检查确保两种前缀功能一致性

#### 迁移时机判断
**挑战**: 何时可以安全弃用 BMad 前缀存在不确定性
**应对**: 
- 建立用户使用数据收集机制
- 设定明确的迁移评估指标（如pm使用率>80%）
- 保持BMad支持直到用户自然迁移完成

## 遵循

### 实施原则

#### 兼容性原则
1. **零破坏性**: 任何变更不能破坏现有BMad命令功能
2. **功能对等**: pm命令必须提供与BMad完全相同的功能
3. **错误兼容**: 错误处理和异常信息保持一致性

#### 用户引导原则  
1. **渐进式**: 不强制用户立即切换，允许自然过渡
2. **信息透明**: 清楚告知用户两种前缀的关系和区别
3. **选择自由**: 用户可以继续使用BMad或切换到pm

#### 技术实现原则
1. **映射透明**: 别名映射不能引入额外的性能开销
2. **错误一致**: 两种前缀的错误信息和帮助文档保持一致
3. **测试覆盖**: 确保pm和BMad命令的测试覆盖率相同

### 开发实践

#### 代码组织
```python
# 统一的命令实现层
class BaseCommand:
    def execute(self, args): pass

# 前缀映射层
class PrefixRouter:
    def route(self, prefix, command, args):
        if prefix in ['pm', 'BMad']:
            return BaseCommand().execute(args)
```

#### 文档维护
1. **主文档**: 优先使用pm前缀展示命令
2. **兼容文档**: 提供BMad命令对照表
3. **迁移指南**: 为想要迁移的用户提供详细指导

#### 测试策略
1. **双前缀测试**: 每个功能都要测试pm和BMad两种调用方式
2. **映射测试**: 验证pm命令正确映射到BMad实现
3. **一致性测试**: 确保两种前缀的输出格式完全一致

#### 监控和反馈
1. **使用统计**: 收集pm vs BMad的使用比例数据
2. **错误跟踪**: 监控别名映射是否引入新的错误
3. **用户反馈**: 定期收集用户对双前缀系统的意见

### 质量保证

#### 性能要求
- 别名映射延迟 < 5ms
- pm命令响应时间与BMad命令相同
- 内存占用增长 < 10%

#### 稳定性要求  
- pm命令可用性与BMad命令相同
- 映射错误率 < 0.01%
- 向后兼容性100%保证

#### 用户体验要求
- 新用户onboarding突出pm命令
- 现有用户transition平滑无感知
- 文档一致性和准确性100%

---
Last Updated: 2025-09-14