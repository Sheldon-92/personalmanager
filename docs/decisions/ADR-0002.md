# ADR-0002: MVP存储路线为本地文件

## 状态
已接受

## 背景

PersonalManager作为个人效能管理工具，需要存储和管理用户的项目数据、任务信息、习惯记录、目标跟踪等多种类型的数据。在系统架构设计阶段，我们面临数据存储技术栈的关键选择。

考虑到目标用户群体的特点：
1. **隐私敏感性高**: 个人效能数据属于高度敏感的个人信息
2. **部署简便性要求**: 用户期望"开箱即用"，避免复杂的环境配置
3. **数据自主性需求**: 用户希望完全掌控自己的数据
4. **离线工作能力**: 在网络环境不稳定时仍需正常工作
5. **迁移便利性**: 数据应该便于备份、迁移和版本控制

同时，作为MVP版本，我们需要在功能完整性、开发效率和用户体验之间找到最佳平衡点。

## 考虑的方案

### 方案1: SQLite数据库
```
优点:
- 成熟的关系型数据库，支持复杂查询
- 单文件部署，无需额外服务
- Python生态系统支持良好
- 支持事务和数据完整性约束

缺点:
- 用户无法直接查看和编辑数据
- 数据格式对用户不透明
- 版本控制困难（二进制文件）
- 数据迁移需要专门工具
- 不支持人工检查和调试
```

### 方案2: 关系型数据库（PostgreSQL/MySQL）
```
优点:
- 性能优异，支持复杂查询和大数据量
- 成熟的数据管理功能
- 强大的数据一致性保证
- 支持高级数据分析

缺点:
- 需要额外的数据库服务器部署
- 增加系统复杂度和维护成本
- 对用户环境有要求
- 与"本地优先"理念不符
- MVP阶段过度设计
```

### 方案3: NoSQL数据库（MongoDB等）
```
优点:
- 文档型存储，结构灵活
- 适合快速迭代的MVP阶段
- 支持复杂的数据结构

缺点:
- 需要额外服务部署
- 学习和维护成本高
- 数据一致性相对较弱
- 不符合简单部署的要求
```

### 方案4: 本地文件存储（选择方案）
```
存储结构:
~/.personalmanager/
├── config/
│   ├── settings.yaml        # 系统配置
│   └── user_profile.yaml    # 用户画像
├── data/
│   ├── projects/           # 项目数据
│   │   └── {project_id}.json
│   ├── tasks/              # 任务数据
│   │   └── {date}/
│   │       └── tasks.json
│   ├── goals/              # 目标数据
│   │   └── goals.json
│   └── habits/             # 习惯数据
│       └── habits.json
└── cache/
    ├── recommendations.json
    └── analytics.json

优点:
- 完全本地化，保护用户隐私
- 零配置部署，用户友好
- 数据透明，支持人工检查和编辑
- 支持Git版本控制
- 便于备份和迁移
- 开发调试便利
- 支持渐进式迁移到其他存储

缺点:
- 复杂查询性能相对较低
- 需要自实现数据一致性检查
- 并发访问处理相对复杂
- 大数据量情况下性能受限
```

## 决策

选择**本地文件存储**作为MVP阶段的数据存储方案，采用JSON+YAML的混合格式：

### 技术实现原则

1. **分类存储**: 按数据类型和时间维度分目录存储
2. **格式选择**: 
   - 配置文件使用YAML（人类友好）
   - 数据文件使用JSON（程序友好）
3. **目录结构**: 采用语义化的目录命名
4. **版本兼容**: 所有数据文件包含schema_version字段

### 数据管理策略

1. **原子性写入**: 使用临时文件+重命名确保写入原子性
2. **定期备份**: 自动创建时间戳备份
3. **数据验证**: 读取时进行schema验证
4. **缓存机制**: 热数据内存缓存，减少I/O

### 迁移路径设计

设计时考虑未来向数据库迁移的可能：
1. 抽象数据访问层（Repository模式）
2. 标准化数据模型（Pydantic）
3. 预留数据库适配器接口
4. 提供数据导出/导入工具

## 结果

这个决策带来以下影响：

### 积极影响

#### 用户体验提升
- **零配置启动**: 用户无需安装配置数据库
- **数据透明性**: 用户可直接查看和编辑数据文件
- **隐私保护**: 数据完全本地化，无网络传输风险
- **备份简单**: 直接复制目录即可完成备份

#### 开发效率提升
- **调试便利**: 可直接查看数据文件内容
- **快速迭代**: 修改数据结构无需数据库迁移
- **测试简化**: 测试数据管理更加便利
- **部署简单**: 无需考虑数据库环境差异

#### 产品定位强化
- **本地优先**: 强化了工具的本地化定位
- **用户自主**: 提升了用户对数据的掌控感
- **版本控制**: 支持将个人数据纳入版本管理

### 潜在挑战与对策

#### 性能考虑
- **问题**: 大数据量时查询性能下降
- **对策**: 
  - 实现智能缓存机制
  - 按时间维度分片存储
  - 预留数据库迁移接口

#### 数据一致性
- **问题**: 缺乏数据库级别的一致性保证
- **对策**:
  - 实现应用级别的数据验证
  - 使用文件锁防止并发冲突
  - 定期数据完整性检查

#### 并发访问
- **问题**: 多进程访问时可能出现冲突
- **对策**:
  - 实现文件级锁定机制
  - 设计合理的重试策略
  - 监控工具使用独立的文件锁

## 遵循

实施该决策需要遵循以下原则或实践：

### 数据管理原则

1. **文件原子性**: 所有写操作使用临时文件+原子重命名
2. **Schema版本**: 每个数据文件必须包含版本信息
3. **向前兼容**: 新版本必须能读取旧版本数据
4. **错误恢复**: 提供数据损坏检测和恢复机制

### 开发实践

1. **Repository模式**: 使用统一的数据访问抽象层
2. **数据验证**: 使用Pydantic进行严格的数据模型验证
3. **缓存策略**: 实现合理的内存缓存，平衡性能与内存使用
4. **日志记录**: 详细记录数据操作日志，便于问题排查

### 文件组织规范

1. **目录结构**: 严格按照设计的目录结构组织文件
2. **命名约定**: 使用一致的文件命名约定
3. **权限管理**: 适当设置文件和目录权限
4. **清理策略**: 实现过期数据的自动清理机制

### 迁移准备

1. **接口抽象**: 数据访问必须通过抽象接口
2. **标准格式**: 使用标准的数据交换格式
3. **导出工具**: 提供完整的数据导出功能
4. **文档维护**: 维护完整的数据格式文档

### 安全考虑

1. **权限控制**: 确保数据文件只有用户可读写
2. **敏感数据**: 考虑对敏感信息进行加密存储
3. **备份策略**: 实现安全的备份和恢复机制
4. **清理机制**: 提供安全的数据清理功能

---
Last Updated: 2025-01-15