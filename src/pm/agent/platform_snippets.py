"""平台片段生成模块 - 将编译后的提示转换为 Claude/Gemini 平台格式"""

import json
from typing import Dict, Any


def to_claude(doc: str) -> str:
    """
    生成 Claude 平台的 project-instructions.md 内容

    Args:
        doc: 编译后的系统提示

    Returns:
        适合写入 .claude/project-instructions.md 的内容
    """
    # Claude 支持直接使用 Markdown 格式
    # 添加 Claude 特定的元数据头部
    lines = []

    # 元数据注释
    lines.append("<!-- PersonalManager Agent Instructions -->")
    lines.append("<!-- Generated by pm agent prompt compiler -->")
    lines.append("<!-- DO NOT EDIT MANUALLY - This file is auto-generated -->")
    lines.append("")

    # 主要内容
    lines.append(doc)

    # Claude 特定的尾部说明
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Claude 平台特定说明")
    lines.append("")
    lines.append("1. **工具调用**: 使用 PersonalManager CLI 工具时，始终使用 `pm` 命令前缀")
    lines.append("2. **路径处理**: 项目路径相对于当前工作目录")
    lines.append("3. **错误恢复**: 遇到错误时，首先尝试 `pm doctor` 诊断问题")
    lines.append("4. **会话持久**: 记忆和偏好在会话间不会自动保存，需要显式调用相关命令")

    return '\n'.join(lines)


def to_gemini(doc: str) -> Dict[str, Any]:
    """
    生成 Gemini 平台的配置片段

    Args:
        doc: 编译后的系统提示

    Returns:
        适合追加到 ~/.gemini/config.json 的配置片段
    """
    # Gemini 使用 JSON 配置格式
    # 将 Markdown 转换为结构化配置

    config_snippet = {
        "_comment": "PersonalManager Agent Configuration",
        "_generated_by": "pm agent prompt compiler",
        "_warning": "DO NOT EDIT MANUALLY - This snippet is auto-generated",

        "personalmanager": {
            "enabled": True,
            "version": "1.0",

            # 系统提示作为单个字符串
            "system_prompt": doc,

            # Gemini 特定配置
            "platform_specific": {
                "model_preferences": {
                    "temperature": 0.7,
                    "max_tokens": 2048,
                    "top_p": 0.95
                },

                "tool_integration": {
                    "command_prefix": "pm",
                    "auto_confirm": False,
                    "timeout_seconds": 30
                },

                "context_management": {
                    "preserve_workspace": True,
                    "auto_load_project_status": True,
                    "memory_persistence": "session"
                }
            },

            # 功能开关
            "features": {
                "startup_ritual": True,
                "natural_language_routing": True,
                "error_recovery": True,
                "privacy_mode": True
            },

            # 错误处理映射
            "error_handling": {
                "E1xxx": {"action": "suggest_setup", "command": "pm setup"},
                "E2xxx": {"action": "check_permissions", "command": "pm doctor"},
                "E3xxx": {"action": "validate_input", "command": "pm help"},
                "E4xxx": {"action": "check_integration", "command": "pm auth status"}
            }
        }
    }

    # 添加追加策略说明
    config_snippet["_append_strategy"] = {
        "description": "This snippet should be merged with existing config",
        "merge_rules": [
            "If 'personalmanager' key exists, replace it entirely",
            "Preserve all other top-level keys",
            "Create backup before modification"
        ],
        "example_command": "jq '. * input' ~/.gemini/config.json snippet.json > ~/.gemini/config.json.new"
    }

    return config_snippet


def to_gemini_script(doc: str) -> str:
    """
    生成用于安全追加 Gemini 配置的 shell 脚本

    Args:
        doc: 编译后的系统提示

    Returns:
        Shell 脚本内容
    """
    snippet = to_gemini(doc)
    snippet_json = json.dumps(snippet, indent=2, ensure_ascii=False)

    script = f'''#!/bin/bash
# PersonalManager Gemini 配置追加脚本
# 使用方法: bash append_gemini_config.sh

set -e

GEMINI_CONFIG="$HOME/.gemini/config.json"
BACKUP_FILE="$GEMINI_CONFIG.backup.$(date +%Y%m%d_%H%M%S)"

# 检查 jq 是否安装
if ! command -v jq &> /dev/null; then
    echo "错误: 需要安装 jq 工具"
    echo "请运行: brew install jq (macOS) 或 apt-get install jq (Linux)"
    exit 1
fi

# 创建目录（如果不存在）
mkdir -p "$HOME/.gemini"

# 备份现有配置（如果存在）
if [ -f "$GEMINI_CONFIG" ]; then
    echo "备份现有配置到: $BACKUP_FILE"
    cp "$GEMINI_CONFIG" "$BACKUP_FILE"
else
    echo "创建新配置文件"
    echo '{{}}' > "$GEMINI_CONFIG"
fi

# PersonalManager 配置片段
PM_SNIPPET=$(cat <<'END_SNIPPET'
{snippet_json}
END_SNIPPET
)

# 合并配置
echo "正在更新 Gemini 配置..."
echo "$PM_SNIPPET" | jq -s '.[0] * .[1]' "$GEMINI_CONFIG" - > "$GEMINI_CONFIG.tmp"

# 验证生成的 JSON
if jq empty "$GEMINI_CONFIG.tmp" 2>/dev/null; then
    mv "$GEMINI_CONFIG.tmp" "$GEMINI_CONFIG"
    echo "✅ Gemini 配置更新成功"
    echo "配置文件: $GEMINI_CONFIG"
else
    echo "❌ 配置合并失败，保留原配置"
    rm -f "$GEMINI_CONFIG.tmp"
    exit 1
fi
'''

    return script


def validate_platform_output(platform: str, output: Any) -> bool:
    """
    验证平台输出格式是否正确

    Args:
        platform: 'claude' 或 'gemini'
        output: 平台输出内容

    Returns:
        是否有效
    """
    if platform == 'claude':
        # Claude 输出应该是字符串
        if not isinstance(output, str):
            return False
        # 检查必要的标记
        required_markers = [
            "PersonalManager Expert",
            "角色与职责",
            "隐私与安全"
        ]
        return all(marker in output for marker in required_markers)

    elif platform == 'gemini':
        # Gemini 输出应该是字典
        if not isinstance(output, dict):
            return False
        # 检查必要的键
        required_keys = ['personalmanager', '_comment', '_append_strategy']
        return all(key in output for key in required_keys)

    return False