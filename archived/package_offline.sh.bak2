#!/bin/bash

# PersonalManager Offline Packaging Script
# Creates a self-contained offline installation package

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
BUILD_DIR="${PROJECT_ROOT}/build/offline"
PACKAGE_NAME="personalmanager-offline"
VERSION=$(python3 -c "import toml; print(toml.load('${PROJECT_ROOT}/pyproject.toml')['tool']['poetry']['version'])" 2>/dev/null || echo "0.1.0")
ARCHIVE_NAME="${PACKAGE_NAME}-v${VERSION}.tar.gz"
REQUIREMENTS_FILE="${BUILD_DIR}/requirements.txt"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Print usage
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Creates an offline installation package for PersonalManager

OPTIONS:
    --help              Show this help message
    --version           Show version information
    --output DIR        Output directory (default: ./dist)
    --include-dev       Include development dependencies
    --compress LEVEL    Compression level 1-9 (default: 6)
    --platform          Target platform (auto-detect by default)
    --verbose           Enable verbose output
    --clean             Clean build directory before packaging
    --sign              Sign the package with GPG (requires GPG setup)
    --gpg-key ID        GPG key ID for signing (uses default if not specified)
EXAMPLES:
    $0                          # Create basic offline package
    $0 --include-dev            # Include development dependencies
    $0 --output ~/packages      # Output to custom directory
    $0 --compress 9 --clean     # Maximum compression, clean build

EOF
}

# Parse command line arguments
INCLUDE_DEV=false
OUTPUT_DIR="${PROJECT_ROOT}/dist"
COMPRESS_LEVEL=6
VERBOSE=false
CLEAN=false
PLATFORM=""
SIGN_PACKAGE=false
GPG_KEY_ID=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --help)
            usage
            exit 0
            ;;
        --version)
            echo "PersonalManager Offline Packager v${VERSION}"
            exit 0
            ;;
        --output)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --include-dev)
            INCLUDE_DEV=true
            shift
            ;;
        --compress)
            COMPRESS_LEVEL="$2"
            shift 2
            ;;
        --platform)
            PLATFORM="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --clean)
            CLEAN=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Verbose logging
verbose_log() {
    if [[ "$VERBOSE" == "true" ]]; then
        log_info "$1"
    fi
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    # Check Python version
    if ! command -v python3 &> /dev/null; then
        log_error "Python 3 is required but not found"
        exit 1
    fi

    local python_version
    python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    if [[ $(echo "$python_version >= 3.9" | bc -l 2>/dev/null || python3 -c "print(float('$python_version') >= 3.9)") != "True" ]] && [[ $(python3 -c "import sys; print(sys.version_info >= (3, 9))") != "True" ]]; then
        log_error "Python 3.9 or higher is required (found: $python_version)"
        exit 1
    fi

    # Check required tools
    local required_tools=("tar" "pip")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log_error "Required tool '$tool' is not available"
            exit 1
        fi
    done

    # Check if we're in the correct directory
    if [[ ! -f "${PROJECT_ROOT}/pyproject.toml" ]]; then
        log_error "Not in PersonalManager project root (pyproject.toml not found)"
        exit 1
    fi

    verbose_log "Python version: $python_version"
    verbose_log "Project root: $PROJECT_ROOT"
    log_success "Prerequisites check passed"
}

# Detect platform
detect_platform() {
    if [[ -z "$PLATFORM" ]]; then
        case "$(uname -s)" in
            Darwin*)    PLATFORM="macos-$(uname -m)" ;;
            Linux*)
                if [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                    PLATFORM="wsl-$(uname -m)"
                else
                    PLATFORM="linux-$(uname -m)"
                fi
                ;;
            CYGWIN*|MINGW*|MSYS*) PLATFORM="windows-$(uname -m)" ;;
            *)          PLATFORM="unknown-$(uname -m)" ;;
        esac
    fi
    verbose_log "Target platform: $PLATFORM"
}

# Clean build directory
clean_build_dir() {
    if [[ "$CLEAN" == "true" ]] && [[ -d "$BUILD_DIR" ]]; then
        log_info "Cleaning build directory..."
        rm -rf "$BUILD_DIR"
        verbose_log "Removed: $BUILD_DIR"
    fi
}

# Create build directory structure
setup_build_dir() {
    log_info "Setting up build directory..."
    mkdir -p "$BUILD_DIR"
    mkdir -p "$BUILD_DIR/src"
    mkdir -p "$BUILD_DIR/dependencies"
    mkdir -p "$BUILD_DIR/bin"
    mkdir -p "$BUILD_DIR/config"
    mkdir -p "$BUILD_DIR/docs"
    verbose_log "Build directory: $BUILD_DIR"
}

# Copy source code
copy_source() {
    log_info "Copying source code..."

    # Copy main source
    cp -r "$PROJECT_ROOT/src" "$BUILD_DIR/"

    # Copy configuration files
    cp "$PROJECT_ROOT/pyproject.toml" "$BUILD_DIR/"
    cp "$PROJECT_ROOT/README.md" "$BUILD_DIR/"
    cp "$PROJECT_ROOT/INSTALL_GUIDE.md" "$BUILD_DIR/"

    # Copy essential scripts and executables
    cp -r "$PROJECT_ROOT/bin" "$BUILD_DIR/"

    # Copy essential documentation
    if [[ -d "$PROJECT_ROOT/docs" ]]; then
        mkdir -p "$BUILD_DIR/docs"
        cp -r "$PROJECT_ROOT/docs/installation" "$BUILD_DIR/docs/" 2>/dev/null || true
        cp -r "$PROJECT_ROOT/docs/user_guide" "$BUILD_DIR/docs/" 2>/dev/null || true
    fi

    # Copy essential configuration templates
    if [[ -d "$PROJECT_ROOT/config-templates" ]]; then
        cp -r "$PROJECT_ROOT/config-templates" "$BUILD_DIR/"
    fi

    verbose_log "Source code copied to build directory"
}

# Generate requirements file
generate_requirements() {
    log_info "Generating requirements file..."

    cd "$PROJECT_ROOT"

    if command -v poetry &> /dev/null; then
        verbose_log "Using Poetry to export requirements"
        if [[ "$INCLUDE_DEV" == "true" ]]; then
            poetry export -f requirements.txt --output "$REQUIREMENTS_FILE" --without-hashes --dev
        else
            poetry export -f requirements.txt --output "$REQUIREMENTS_FILE" --without-hashes
        fi
    else
        verbose_log "Poetry not available, generating basic requirements"
        # Fallback: extract dependencies from pyproject.toml
        python3 -c "
import toml
import sys

try:
    config = toml.load('pyproject.toml')
    deps = config['tool']['poetry']['dependencies']

    # Filter out python version constraint
    filtered_deps = {k: v for k, v in deps.items() if k != 'python'}

    for name, version in filtered_deps.items():
        if isinstance(version, str):
            if version.startswith('^'):
                version = '>=' + version[1:]
            print(f'{name}{version}')
        else:
            print(name)

except Exception as e:
    print(f'Error generating requirements: {e}', file=sys.stderr)
    sys.exit(1)
" > "$REQUIREMENTS_FILE"
    fi

    # Add essential packages that might be missing
    echo "" >> "$REQUIREMENTS_FILE"
    echo "# Essential packages" >> "$REQUIREMENTS_FILE"
    echo "setuptools>=60.0.0" >> "$REQUIREMENTS_FILE"
    echo "wheel>=0.37.0" >> "$REQUIREMENTS_FILE"
    echo "pip>=21.0.0" >> "$REQUIREMENTS_FILE"

    verbose_log "Requirements file generated with $(wc -l < "$REQUIREMENTS_FILE") entries"
}

# Download dependencies
download_dependencies() {
    log_info "Downloading Python dependencies..."

    local deps_dir="$BUILD_DIR/dependencies"

    # Create a virtual environment for clean dependency resolution
    local venv_dir="$BUILD_DIR/.temp_venv"
    python3 -m venv "$venv_dir"

    # Use the virtual environment
    source "$venv_dir/bin/activate"

    # Upgrade pip in venv
    pip install --upgrade pip setuptools wheel

    verbose_log "Downloading packages to: $deps_dir"

    # Download all dependencies
    pip download \
        --requirement "$REQUIREMENTS_FILE" \
        --dest "$deps_dir" \
        --no-deps \
        --platform "$PLATFORM" \
        --implementation py \
        --python-version "$(python3 -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")" \
        2>/dev/null || {
            log_warning "Platform-specific download failed, trying generic approach..."
            pip download --requirement "$REQUIREMENTS_FILE" --dest "$deps_dir"
        }

    # Also download with dependencies to ensure we have everything
    pip download \
        --requirement "$REQUIREMENTS_FILE" \
        --dest "$deps_dir" \
        2>/dev/null || log_warning "Some dependencies might be missing"

    # Clean up virtual environment
    deactivate
    rm -rf "$venv_dir"

    local dep_count
    dep_count=$(find "$deps_dir" -name "*.whl" -o -name "*.tar.gz" | wc -l)
    verbose_log "Downloaded $dep_count dependency packages"
    log_success "Dependencies downloaded successfully"
}

# Create offline installer script
create_installer() {
    log_info "Creating offline installer script..."

    cat > "$BUILD_DIR/install_offline.sh" << 'EOF'
#!/bin/bash

# PersonalManager Offline Installer
# Self-contained installation script with embedded dependencies

set -euo pipefail

INSTALL_DIR="${1:-$HOME/.local/personalmanager}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check Python
check_python() {
    log_info "Checking Python installation..."

    if ! command -v python3 &> /dev/null; then
        log_error "Python 3 is required but not found"
        exit 1
    fi

    local version
    version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")

    if ! python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 9) else 1)"; then
        log_error "Python 3.9+ is required (found: $version)"
        exit 1
    fi

    log_success "Python $version is compatible"
}

# Install PersonalManager
install_pm() {
    log_info "Installing PersonalManager to: $INSTALL_DIR"

    # Create installation directory
    mkdir -p "$INSTALL_DIR"

    # Copy source files
    cp -r "$SCRIPT_DIR/src" "$INSTALL_DIR/"
    cp -r "$SCRIPT_DIR/bin" "$INSTALL_DIR/"
    cp "$SCRIPT_DIR/pyproject.toml" "$INSTALL_DIR/"
    cp "$SCRIPT_DIR/README.md" "$INSTALL_DIR/"

    # Copy configuration templates if they exist
    if [[ -d "$SCRIPT_DIR/config-templates" ]]; then
        cp -r "$SCRIPT_DIR/config-templates" "$INSTALL_DIR/"
    fi

    # Install dependencies from local packages
    log_info "Installing dependencies from local packages..."

    # Create virtual environment
    python3 -m venv "$INSTALL_DIR/venv"
    source "$INSTALL_DIR/venv/bin/activate"

    # Upgrade pip
    pip install --upgrade pip setuptools wheel

    # Install from local dependencies
    pip install --no-index --find-links "$SCRIPT_DIR/dependencies" -r "$SCRIPT_DIR/requirements.txt"

    # Install PersonalManager itself
    cd "$INSTALL_DIR"
    pip install -e .

    deactivate

    # Make launcher executable
    chmod +x "$INSTALL_DIR/bin/pm-local"

    log_success "Installation completed"
}

# Create launcher wrapper
create_launcher() {
    log_info "Creating system launcher..."

    local launcher_path="$HOME/.local/bin/pm"
    mkdir -p "$(dirname "$launcher_path")"

    cat > "$launcher_path" << LAUNCHER
#!/bin/bash
# PersonalManager System Launcher
INSTALL_DIR="$INSTALL_DIR"
source "\$INSTALL_DIR/venv/bin/activate"
"\$INSTALL_DIR/bin/pm-local" "\$@"
LAUNCHER

    chmod +x "$launcher_path"

    log_success "Launcher created at: $launcher_path"

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
        log_warning "Add $HOME/.local/bin to your PATH to use 'pm' command globally"
        echo "Add this to your ~/.bashrc or ~/.zshrc:"
        echo "export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi
}

# Run installation
main() {
    echo "PersonalManager Offline Installer"
    echo "================================="

    check_python
    install_pm
    create_launcher

    echo
    log_success "PersonalManager installed successfully!"
    echo
    echo "Next steps:"
    echo "1. Add ~/.local/bin to your PATH (if not already)"
    echo "2. Run: pm setup"
    echo "3. Run: pm doctor"
    echo "4. Start using: pm today"
    echo
    echo "For help: pm --help"
}

# Check if script is sourced or executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
EOF

    chmod +x "$BUILD_DIR/install_offline.sh"
    verbose_log "Offline installer script created"
}

# Create version info file
create_version_info() {
    log_info "Creating version information..."

    local build_time
    build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat > "$BUILD_DIR/VERSION_INFO.txt" << EOF
PersonalManager Offline Package
===============================

Version: $VERSION
Platform: $PLATFORM
Build Date: $build_time
Python Version: $(python3 --version)
Build Host: $(hostname)
Build User: $(whoami)

Package Contents:
- PersonalManager source code
- All Python dependencies
- Offline installer script
- Documentation and configuration templates

Installation:
1. Extract the package
2. Run: ./install_offline.sh [install_directory]
3. Follow the prompts

For support, see INSTALL_GUIDE.md
EOF

    verbose_log "Version info file created"
}

# Create checksums
create_checksums() {
    log_info "Creating checksums..."

    cd "$BUILD_DIR"

    # Create checksums for important files
    {
        echo "# PersonalManager Offline Package Checksums"
        echo "# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        echo

        find . -type f \( -name "*.py" -o -name "*.sh" -o -name "*.txt" -o -name "*.md" \) \
            -exec sha256sum {} \; | sort

        echo
        echo "# Dependencies"
        find dependencies/ -type f \( -name "*.whl" -o -name "*.tar.gz" \) \
            -exec sha256sum {} \; | sort
    } > CHECKSUMS.sha256

    verbose_log "Checksums created in CHECKSUMS.sha256"
}

# Create the final archive
create_archive() {
    log_info "Creating final package archive..."

    # Ensure output directory exists
    mkdir -p "$OUTPUT_DIR"

    local archive_path="$OUTPUT_DIR/$ARCHIVE_NAME"

    # Create tarball with compression
    cd "$(dirname "$BUILD_DIR")"
    tar -czf "$archive_path" \
        --exclude='.temp_venv' \
        --exclude='__pycache__' \
        --exclude='*.pyc' \
        "$(basename "$BUILD_DIR")"

    local archive_size
    archive_size=$(du -h "$archive_path" | cut -f1)

    log_success "Package created: $archive_path ($archive_size)"

    # Calculate final size
    local size_mb
    size_mb=$(du -m "$archive_path" | cut -f1)

    if [[ $size_mb -gt 50 ]]; then
        log_warning "Package size ($size_mb MB) exceeds recommended limit (50MB)"
    else
        log_success "Package size ($size_mb MB) is within limits"
    fi

    # Create checksum for the archive
    cd "$OUTPUT_DIR"
    sha256sum "$ARCHIVE_NAME" > "${ARCHIVE_NAME}.sha256"

    verbose_log "Archive checksum: $(cat "${ARCHIVE_NAME}.sha256")"
}

# Show package information
show_package_info() {
    log_info "Package Information:"
    echo "===================="
    echo "Name: $PACKAGE_NAME"
    echo "Version: $VERSION"
    echo "Platform: $PLATFORM"
    echo "Archive: $OUTPUT_DIR/$ARCHIVE_NAME"
    echo "Size: $(du -h "$OUTPUT_DIR/$ARCHIVE_NAME" 2>/dev/null | cut -f1 || echo "Unknown")"
    echo
    echo "Installation commands:"
    echo "  tar -xzf $ARCHIVE_NAME"
    echo "  cd $(basename "$BUILD_DIR")"
    echo "  ./install_offline.sh"
    echo
}

# Cleanup temporary files
cleanup() {
    if [[ -n "${BUILD_DIR:-}" ]] && [[ -d "$BUILD_DIR/.temp_venv" ]]; then
        rm -rf "$BUILD_DIR/.temp_venv"
        verbose_log "Cleaned up temporary files"
    fi
}

# Main execution
main() {
    log_info "Starting PersonalManager offline packaging..."
    log_info "Version: $VERSION, Platform: $PLATFORM"

    # Set up cleanup trap
    trap cleanup EXIT

    check_prerequisites
    detect_platform
    clean_build_dir
    setup_build_dir
    copy_source
    generate_requirements
    download_dependencies
    create_installer
    create_version_info
    create_checksums
    create_archive
    show_package_info

    log_success "Offline package creation completed successfully!"

    # Output JSON result for task completion
    cat << EOF

{
  "status": "success",
  "command": "T-PACK.package_creation",
  "data": {
    "artifacts": ["scripts/package_offline.sh", "$OUTPUT_DIR/$ARCHIVE_NAME"],
    "run_cmds": ["bash scripts/package_offline.sh", "tar -xzf $ARCHIVE_NAME && cd offline && ./install_offline.sh"],
    "metrics": {
      "package_size_mb": $(du -m "$OUTPUT_DIR/$ARCHIVE_NAME" 2>/dev/null | cut -f1 || echo 0),
      "build_time_sec": $SECONDS,
      "platform": "$PLATFORM",
      "python_version": "$(python3 --version | cut -d' ' -f2)"
    }
  },
  "metadata": {
    "version": "$VERSION",
    "execution_time": $SECONDS,
    "package_path": "$OUTPUT_DIR/$ARCHIVE_NAME"
  }
}
EOF
}

# Execute main function
main "$@"
# Enhanced signing and verification functions for T-DIST

# Sign the package archive with GPG
sign_archive() {
    local archive_path="$1"
    
    log_info "Signing package with GPG..."
    
    cd "$(dirname "$archive_path")"
    local archive_name="$(basename "$archive_path")"
    
    # Create GPG signature
    local gpg_cmd="gpg --detach-sign --armor"
    if [[ -n "$GPG_KEY_ID" ]]; then
        gpg_cmd="$gpg_cmd --local-user $GPG_KEY_ID"
    fi
    
    if $gpg_cmd "$archive_name" 2>/dev/null; then
        log_success "GPG signature created: ${archive_name}.asc"
        verbose_log "Signature file: $(realpath "${archive_name}.asc")"
    else
        log_error "Failed to create GPG signature"
        return 1
    fi
    
    return 0
}

# Create integrity manifest with detailed verification info
create_integrity_manifest() {
    log_info "Creating integrity manifest..."
    
    cd "$BUILD_DIR"
    
    local manifest_file="INTEGRITY_MANIFEST.json"
    local build_time
    build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    # Generate detailed manifest
    cat > "$manifest_file" << MANIFEST_EOF
{
  "package": {
    "name": "$PACKAGE_NAME",
    "version": "$VERSION",
    "platform": "$PLATFORM",
    "build_time": "$build_time",
    "build_host": "$(hostname)",
    "build_user": "$(whoami)",
    "python_version": "$(python3 --version | cut -d' ' -f2)"
  },
  "checksums": {
    "algorithm": "SHA256",
    "files": {
MANIFEST_EOF
    
    # Add file checksums to JSON
    local first_file=true
    find . -type f ! -name "$manifest_file" ! -name "*.sig" ! -name "*.asc" | while read -r file; do
        local checksum
        checksum=$(sha256sum "$file" | cut -d' ' -f1)
        local file_clean="${file#./}"
        
        if [[ "$first_file" != "true" ]]; then
            echo "," >> "$manifest_file"
        fi
        echo -n "      \"$file_clean\": \"$checksum\"" >> "$manifest_file"
        first_file=false
    done
    
    cat >> "$manifest_file" << MANIFEST_EOF

    }
  },
  "dependencies": {
    "count": $(find dependencies/ -name "*.whl" -o -name "*.tar.gz" 2>/dev/null | wc -l),
    "total_size_mb": $(du -sm dependencies/ 2>/dev/null | cut -f1 || echo 0)
  },
  "verification": {
    "method": "sha256sum + gpg",
    "signed": $SIGN_PACKAGE,
    "created": "$build_time"
  }
}
MANIFEST_EOF
    
    verbose_log "Integrity manifest created: $manifest_file"
}

